<!DOCTYPE html><html lang="en">
<head><meta charset="utf-8">
<!--
Copyright (c) 2025 OCA (https://www.youtube.com/@OCAudiophile)

All rights reserved.

This software is free to use and is licensed under the following terms:

Permission is granted to:

- Share: Copy and redistribute the material in its original, unmodified form, in any medium or format, provided this full license notice is included and no alterations are made to the content or functionality.

Restrictions:

- Attribution: You must provide appropriate credit to the original author (OCA), include a link to the official project or source (https://www.youtube.com/@OCAudiophile), and reproduce this license notice in full with every copy.
- NonCommercial: You may not use the material for commercial purposes under any circumstances.
- No Modifications: You may not modify, adapt, remix, transform, translate, convert to other languages, automate, integrate into other works, or otherwise alter the material in any way without explicit written permission from the author.
- No Additional Use: Any use beyond exact duplication and sharing of the original, unmodified work—including but not limited to incorporation into other projects or systems—requires prior written consent from the author.

Special Notice:

- The algorithms, structure, and functionality contained in this script are proprietary and may not be used, reproduced, or adapted for any purpose—commercial or non-commercial—without explicit written permission from the author.
- Any permitted modified versions must:
• Be explicitly authorized in writing by the author prior to creation, use, or distribution.
• Clearly indicate they are modified from the original.
• Include this license notice in full.
• Attribute the original author and provide a link to the official project or source.

Disclaimer:

This software is provided "as is", without warranty of any kind, express or implied,
including but not limited to the warranties of merchantability, fitness for a particular purpose,
and noninfringement. Use at your own risk.
-->
<title>A1 Evo Acoustica</title>
<style>
  body {
    margin: 0;
    font-family: 'Inter', 'Segoe UI', Roboto, sans-serif;
    background-color: #0F172A;
    color: #F1F5F9;
    overflow-y: scroll;
    overflow-x: auto;
    min-height: 100vh;
    padding: 20px;
  }
  #measurementChoice {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    min-height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
  }
  .card {
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
    max-width: 1000px;
    width: 100%;
    text-align: center;
    background: linear-gradient(135deg, #1E293B, #3B82F6);
    transform: scale(1);
    transition: all 0.3s ease;
  }
  .card:hover {
    transform: scale(1.02);
  }
  .button {
    display: inline-block;
    padding: 16px 16px;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    border-radius: 12px;
    border: none;
    margin: 12px 0;
    width: calc(80% - 0px);
    text-transform: uppercase;
    background: linear-gradient(45deg, #3B82F6, #22c55e, #a855f7);
    color: #fff;
    box-shadow: 0 10px 20px rgba(37, 99, 235, 0.5);
    transition: all 0.3s ease;
  }
  .button2 {
    display: inline-block;
    padding: 16px 16px;
    font-size: 15px;
    font-weight: bold;
    cursor: pointer;
    border-radius: 12px;
    border: none;
    margin: 12px 0;
    width: calc(40% - 0px);
    text-transform: uppercase;
    background: linear-gradient(45deg, #3B82F6, #22c55e);
    color: #fff;
    box-shadow: 0 10px 20px rgba(37, 99, 235, 0.5);
    transition: all 0.3s ease;
  }
  .button2:hover {
    background: linear-gradient(45deg, #1E40AF, #166534);
    color: #fff;
    box-shadow: 0 14px 30px rgba(21, 128, 61, 0.6);
    transform: translateY(-2px) scale(1.03);
  }
  .link-container {
    display: flex;
    justify-content: center;
    gap: 60px;
    font-size: 1rem;
    margin-top: 18px;
  }
  .link-container a {
    text-decoration: underline;
    color: #99B3ED;
    transition: color 0.3s ease, transform 0.3s ease;
  }
  .link-container a:hover {
    color: #4299E1;
    transform: scale(1.05);
    text-decoration: none;
  }
  p {
    margin: 12px 0;
    font-size: 1rem;
    color: #CBD5E0;
    line-height: 1.6;
  }
   h1 {
     font-size: 3rem;
     font-weight: 700;
     text-align: center;
     margin: 0 0 0.5rem 0;
     background: linear-gradient(135deg, #10b981, #059669);
     -webkit-background-clip: text;
     -webkit-text-fill-color: transparent;
     text-shadow: 0 0 30px rgba(165, 243, 252, 0.6), 0 0 10px rgba(74, 222, 128, 0.4);
     animation: textGlow 3s ease-in-out infinite;
   }
   @keyframes textGlow {
     0%, 100% { text-shadow: 0 0 20px rgba(165, 243, 252, 0.6), 0 0 10px rgba(74, 222, 128, 0.4); }
     50% { text-shadow: 0 0 30px rgba(165, 243, 252, 0.8), 0 0 15px rgba(74, 222, 128, 0.6); }
   }
  h2 {
    text-align: center;
    font-size: 1.2rem;
    font-weight: 300;
    color: #93c5fd;
    margin-bottom: 1rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    animation: fadeIn 2s ease-in;
  }
  @keyframes fadeIn {
    0% { opacity: 0; transform: translateY(20px); }
    100% { opacity: 1; transform: translateY(0); }
  }
  .card, .button, a {
    transition: all 0.3s ease-in-out;
  }
  #startEvo {
    position: relative;
    background: linear-gradient(135deg, #059669, #065F46);
    color: white;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
    overflow: hidden;
  }
  #startEvo::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    animation: shine 5s infinite linear;
    pointer-events: none;
  }
  @keyframes shine {
    0% {left: -100%;}
    100% {left: 100%;}
  }
  #startEvo:hover {
    background: linear-gradient(135deg, #047857, #064E3B);
    transform: scale(1.02);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
  }
  .button-container {
    margin-top: 12px;
  }
  .lowercase-text {
    text-transform: none;}
  .slider-container {
    margin: 10px 0;
    width: 100%;
  }
  .slider-label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
    color: #CBD5E0;
    font-size: 1rem;
  }
  .slider {
    width: 95%;
    height: 6px;
    background: linear-gradient(90deg, #3B82F6, #2D3748);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
  }
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #3B82F6;
    border: 2px solid #1E40AF;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  .slider::-webkit-slider-thumb:hover {
    background: #1E40AF;
    transform: scale(1.1);
    border-color: #2563EB;
  }
  .crossover-sliders {
    display: flex;
    gap: 100px;
  }
  .crossover-slider {
    flex: 1;
  }
  .tooltip-container {
    position: absolute;
    width: 100%;
  }
  .tooltip-container:hover .tooltip {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  }
  .tooltip {
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #555;
    color: #fff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 14px;
    text-align: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
    white-space: nowrap;
  }
  .tooltip::after {
    content: '';
    position: absolute;
    top: 0%;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px;
    border-style: solid;
    border-color: #2A2E37 transparent transparent transparent;
  }
  .tooltip-link {
    position: relative;
    display: inline-block;
  }
  .link-tooltip {
    visibility: hidden;
    width: 150px;
    background-color: #555;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 2px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    font-size: 12px;
    left: 50%;
    margin-left: -87px;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .tooltip-link:hover .link-tooltip {
    visibility: visible;
    opacity: 0.9;
  }
  .link-tooltip::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: #555 transparent transparent transparent;
  }
  .option-container {
    margin: 12px auto;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1rem;
    color: #CBD5E0;
    max-width: 600px;
  }
  .toggle-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    user-select: none;
    position: relative;
  }
  .toggle-label input {
    display: none;
  }
  .toggle-button {
    width: 20px;
    height: 14px;
    background: #4A5568;
    border-radius: 14px;
    position: relative;
    transition: background 0.3s ease;
  }
  .toggle-button::after {
    content: '';
    position: absolute;
    top: 1px;
    left: 1px;
    width: 12px;
    height: 12px;
    background: #CBD5E0;
    border-radius: 50%;
    transition: transform 0.3s ease, background 0.3s ease;
  }
  .toggle-label:hover .toggle-button {
    opacity: 0.9;
  }
  input:checked + .toggle-button {
    background: #3B82F6;
  }
  input:checked + .toggle-button::after {
    transform: translateX(6px);
    background: #FFFFFF;
  }
  .tooltip-container {
    position: relative;
    display: inline-block;
  }
  .tooltip {
    visibility: hidden;
    position: absolute;
    top: 100%;
    left: 0%;
    transform: translateX(0);
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
  }
  .tooltip-container:hover .tooltip {
    visibility: visible;
    opacity: 0.9;
  }
  .rolloff-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    margin-top: 1rem;
	margin-bottom: 2rem;  /* Added this line */
    font-size: 1rem;
  }
  .rolloff-controls {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    flex-wrap: wrap;
  }
  .rolloff-text {
    white-space: nowrap;
    font-size: 0.8rem;
  }
  #rolloffFreqInput,
  #rolloffSlopeSelect,
  #lpf4lfeSlopeSelect {
    padding: 2px 6px;
    border: 1px solid #4A5568;
    border-radius: 4px;
    background-color: #2D3748;
    color: #E2E8F0;
    font-size: 0.8rem;
  }
  #rolloffFreqInput {
    width: 40px;
  }
  #rolloffSlopeSelect,
  #lpf4lfeSlopeSelect {
    min-width: 65px;
    cursor: pointer;
  }
  #lpf4lfeSlopeSelect {
    background-color: #2D3748 !important;
    min-width: 80px;
  }
  #rolloffSlopeSelect:disabled,
  #lpf4lfeSlopeSelect:disabled,
  #rolloffFreqInput:disabled {
    cursor: not-allowed;
    opacity: 0.6;
    color: #A0AEC0;
  }
  #enableRolloff {
    margin-right: 6px;
  }
  .checkbox-label {
    display: flex;
    align-items: center;
    font-size: 1rem;
    cursor: pointer;
  }
  .rolloff-note {
    font-size: 0.85rem;
    opacity: 0.75;
    width: 100%;
    text-align: center;
  }
  .help-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background-color: #888;
    color: white;
    font-size: 16px;
    cursor: help;
    margin-left: 8px;
  }
  #logContainer {
    display: none;
    position: fixed;
    left: 6%;
    bottom: 6%;
    width: 85%;
    height: 85%;
    background: linear-gradient(135deg, #1A202C, #2D3748, #4A5568);
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    font-family: 'Poppins', 'Segoe UI', Roboto, sans-serif;
    font-size: 0.82rem;
    color: #CBD5E0;
    overflow-y: auto;
    z-index: 2000;
    transition: all 0.3s ease-in-out;
    text-align: left;
  }
  #logContainer .log {
    background: rgba(34, 197, 94, 0.15);
    color: #16A34A;
  }
  #logContainer .info {
    background: rgba(59, 130, 246, 0.2);
    color: #4299E1;
  }
  #logContainer .warning {
    background: rgba(237, 181, 74, 0.25);
    color: #ECC94B;
  }
  #logContainer .error {
    background: rgba(245, 101, 101, 0.9);
    color: #4A0000;
    font-weight: bold;
  }
  #logContainer .infoBold {
    background: rgba(59, 130, 246, 0.2);
    color: #3182CE;
    font-weight: bold;
  }
  #logContainer .infoGrey {
    background: rgba(59, 130, 246, 0.1);
    color: rgba(99, 179, 237, 0.5);
  }
  #measurementChoice.card.transitioned {
    position: absolute;
    right: 20px;
    top: 20px;
    width: 250px;
    padding: 20px;
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
    z-index: 1500;
    transform: scale(0.85);
    transition: all 0.3s ease-in-out;
  }
  .manual-load-container {
    display: none;
    padding: 0.6rem;
    margin-top: 1rem;
    background: rgba(31, 41, 55, 0.5);
    border: 1px dashed rgba(59, 130, 246, 0.3);
    border-radius: 0.75rem;
    transition: all 0.3s ease;
  }
  .manual-load-container:hover {
    border-color: rgba(59, 130, 246, 0.5);
    background: rgba(31, 41, 55, 0.7);
  }
  .manual-load-text {
    display: block;
    margin-bottom: 0.8rem;
    color: #ef4444;
    font-weight: 600;
    font-size: 0.95rem;
  }
  .manual-file-input {
    width: 80%;
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: rgba(17, 24, 39, 0.8);
    border: 1px solid rgba(55, 65, 81, 0.7);
    border-radius: 0.5rem;
    color: #e5e7eb;
    font-family: 'Poppins', sans-serif;
    font-size: 1rem;
    transition: all 0.2s ease;
  }
  .manual-file-input:hover {
    border-color: #3B82F6;
    background: rgba(17, 24, 39, 0.9);
  }
  .manual-file-input:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  }
  .manual-error-message {
    color: #f87171;
    margin-top: 0.5rem;
    font-size: 0.85rem;
    min-height: 1.2rem;
  }
  .manual-file-input::file-selector-button {
    padding: 0.5rem 1rem;
    margin-right: 1rem;
    background: linear-gradient(45deg, #1e40af, #3B82F6);
    color: white;
    border: none;
    border-radius: 0.3rem;
    font-family: 'Poppins', sans-serif;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .manual-file-input::file-selector-button:hover {
    background: linear-gradient(45deg, #1e40af, #2563eb);
  }
  .drawer {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-out;
  }
  .drawer.open {
    max-height: 2000px;
    transition: max-height 0.3s ease-in;
  }
  .expert-button {
    background: linear-gradient(135deg, #2563eb, #1e40af);
    color: white;
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    margin: 10px auto;
    display: block;
    width: fit-content;
    transition: all 0.3s ease;
  }
  .expert-button:hover {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
  }
</style>
</head>
<body>
  <div id="measurementChoice">
  <div class="card">
  <h1 style="font-weight: bold;">
  <span style="color: #3B82F6; font-weight: 800;">A1 EVO ACOUSTICA</span>
  </h1>
  <h2>
  <span style="color: #2563EB; font-weight: 200;">Audio Optimization Suite</span>
  </h2>
  <button id="buttonADY" onclick="extractMeasurements()" class="button2">
  Extract measurements from<br><span class="lowercase-text">.ady</span> / <span class="lowercase-text">.mqx<br>&</span><br>import them into REW<br>
  </button>
  <button id="startEvo" onclick="main()" class="button">
  Start optimization using the measurements currently loaded in<br>Room EQ Wizard
  </button>
  <div id="manualLoadSection" class="manual-load-container">
  <span id="manualLoadText" class="manual-load-text"></span>
  <input type="file" id="manualConfigFileInput" class="manual-file-input" accept=".avr">
  <div id="manualLoadError" class="manual-error-message"></div>
  </div>
  <button class="expert-button" onclick="toggleExpertDrawer()">Advanced Settings</button>
  <div id="expertDrawer" class="drawer">
  <h3>
  <span style="color: #ef4444; font-weight: 350;">Warning – decibels ahead! Messing with these settings may hertz your earz.</span>
  </h3>
  <div class="slider-container">
  <div class="slider-label">
  <span>Night listening volume offset:</span>
  <span id="lowVolumeOffset">-18 dB</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="lowVolumeSlider" class="slider" min="0" max="4" step="1" value="2">
  <div class="tooltip">Applied volume adjustment for low-volume listening (relative to standard listening level).</div>
  </div></div>
  <div class="slider-container">
  <div class="crossover-sliders">
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Subwoofer EQ filter boost</span>
  <span id="subBoostValue">5 dB</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="subBoostSlider" class="slider" min="0" max="6" step="0.1" value="0">
  <div class="tooltip">Maximum allowed boost amount for subwoofer EQ filters - 0dB: allows only cut filters</div>
  </div></div>
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Subwoofer target curve infill</span>
  <span id="bassFillValue">0 dB</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="bassFillSlider" class="slider" min="-10" max="10" step="0.5" value="0">
  <div class="tooltip">Subwoofer level adjustment offset to compensate for gaps below the target curve</div>
  </div></div>
  </div></div>
  <div class="slider-container">
  <div class="crossover-sliders">
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Minimum crossover frequency - Front mains</span>
  <span id="minFreqValueFR">40 Hz</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="minFreqSliderFR" class="slider" min="0" max="7" step="1" value="0">
  <div class="tooltip">Select mimimum search frequency for front speakers crossover optimization</div>
  </div>
  </div>
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Maximum crossover frequency - Front mains</span>
  <span id="maxFreqValueFR">250 Hz</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="maxFreqSliderFR" class="slider" min="0" max="10" step="1" value="10">
  <div class="tooltip">Select maximum search frequency for front speakers crossover optimization</div>
  </div>
  </div>
  </div>
  </div>
  <div class="slider-container">
  <div class="crossover-sliders">
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Minimum crossover frequency - Center speaker</span>
  <span id="minFreqValueC">40 Hz</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="minFreqSliderC" class="slider" min="0" max="7" step="1" value="0">
  <div class="tooltip">Select mimimum search frequency for center speaker crossover optimization</div>
  </div>
  </div> 
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Maximum crossover frequency - Center speaker</span>
  <span id="maxFreqValueC">250 Hz</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="maxFreqSliderC" class="slider" min="0" max="10" step="1" value="10">
  <div class="tooltip">Select maximum search frequency for center speaker crossover optimization</div>
  </div>
  </div>
  </div>
  </div>
  <div class="slider-container">
  <div class="crossover-sliders">
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Minimum crossover frequency - All other speakers</span>
  <span id="minFreqValue">40 Hz</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="minFreqSlider" class="slider" min="0" max="7" step="1" value="0">
  <div class="tooltip">Select mimimum search frequency for crossover optimization</div>
  </div>
  </div>
  <div class="crossover-slider">
  <div class="slider-label">
  <span>Maximum crossover frequency - All other speakers</span>
  <span id="maxFreqValue">250 Hz</span>
  </div>
  <div class="tooltip-container">
  <input type="range" id="maxFreqSlider" class="slider" min="0" max="10" step="1" value="10">
  <div class="tooltip">Select maximum search frequency for crossover optimization</div>
  </div>
  </div>
  </div>
  </div>
  <div class="option-container" style="display: flex; flex-direction: row; gap: 0.5px;">
  <div class="tooltip-container">
  <label class="checkbox-label">
  <input type="checkbox" id="disableSpeakerInversion">Fix speaker polarities
  </label>
  <div class="tooltip">Check polarities and invert out of phase speakers</div>
  </div>
  <div class="tooltip-container">
  <label class="checkbox-label">
  <input type="checkbox" id="disableAllPass">Enable allpass filters
  </label>
  <div class="tooltip">Evaluate and add allpass filters to minimize dips below target curve</div>
  </div>
  <div class="tooltip-container">
  <label class="checkbox-label" style="border-bottom: 2px solid #e74c3c; width: fit-content;">
  <input type="checkbox" id="weakBass">Bass was too weak!
  </label>
  <div class="tooltip">Fix sub(s) offset volume problem with certain measurement methods</div>
  </div>
  </div>
  <div class="rolloff-wrapper tooltip-container">
  <label class="checkbox-label">
  <input type="checkbox" id="enableRolloff">Force custom high-pass and low-pass filters for subwoofer(s)
  </label>
  <div class="tooltip">Advanced option for use with special/DIY subwooofer(s) that can extend very low and have custom roll-off profiles</div>
  <div class="rolloff-controls">
  <label class="rolloff-text" for="rolloffFreqInput">HP freq:</label>
  <input type="number" id="rolloffFreqInput" placeholder="25" min="10" max="60" disabled>
  <span class="rolloff-text">Hz&nbsp;</span>
  <label class="rolloff-text" for="rolloffSlopeSelect">&nbsp;HP slope:</label>
  <select id="rolloffSlopeSelect" disabled></select>
  <label class="rolloff-text" for="lpf4lfeSlopeSelect">&nbsp;LP freq:</label>
  <select id="lpf4lfeSlopeSelect" disabled></select>
  </div>
  </div>
  </div>
  <div class="link-container">
  <a href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank" class="tooltip-link">Download latest REW Beta<span class="link-tooltip">Room EQ Wizard Beta version with API support</span>
  </a>
  <a href="https://www.videolan.org/vlc/" target="_blank" class="tooltip-link">Download VLC media player<span class="link-tooltip">Free media player for playing Atmos measurement sweeps with REW if you wish to measure your system manually</span>
  </a>
  <a href="https://www.youtube.com/channel/UCLePp5EV2RR5_Xo7rZnnpnQ?sub_confirmation=1" target="_blank" class="tooltip-link">Ask OCA<span class="link-tooltip">Visit my YouTube channel for comments, support and DSP tutorial videos</span>
  </a>
  <a href="https://www.facebook.com/groups/audysseyone" target="_blank" class="tooltip-link">A1 Evo Facebook group<span class="link-tooltip">Problems, solutions and experience sharing platform with helpful experts and over 2k members</span>
  </a>
  <a href="https://revolut.me/serko70" target="_blank" class="tooltip-link">Support this project<span class="link-tooltip">Make a donation via Revolut</span>
  </a>
  </div>
  </div>
  </div>
  <div id="logContainer">
  </div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/14.0.1/math.min.js"></script>
<script src="micCalData.js"></script>
<script src="antiLPF.js"></script>
<script src="spFilter.js"></script>

<script>
const evoVersion = "6.4";
const baseUrl = 'http://localhost:4735/measurements', speedDelay = 255, maxDistanceLimit = 7.35;
let micCalFile = new Array(16384).fill(0), audioCtx = null;
let jsonName = 'receiver_config.avr';
let jsonType = 'avr';
let jsonContent = null;
let folderPath, localAppPath = null, ocafileName, sOs = null, isCirrusLogic, isGriffin, freqIndex = [], distFL = null, modelDelayLimit, minDistAccuracy, mSec = [], hardNegative, hardPositive, xt32 = true, xt = false;
let nSpeakers = null, nSubs = null, subMinTrim = -12, subMaxTrim = 12, lpf4LFE, filterCompensation, targetCurvePath, targetLevel, responseTarget, dataTarget, tcName, rewMaxLimit, isPreProcessed = false, isAutomated;
let customLevel = [], commandId = [], customDistance = [], customInvert = [], customCrossover = [], customFilter = [], deqFilter = [], subTrim = [], customMinFreq = [], customMaxFreq = [], customMinFreqFR = [], customMaxFreqFR = [], customMinFreqC = [], customMaxFreqC = [],customMargin = [], subAllPassQ = null, allpassQ = [];
const defaultSlope = "L-R4";
const dbValues = [-12, -15, -18, -20, -25];
var subBoost = 0, bassFill = 0, levelLowVol = 2, enableInversion = false, enableWeakBass = false, noAllpass = false, minFreq = 40, maxFreq = 250, minFreqFR = 40, maxFreqFR = 250, minFreqC = 40, maxFreqC = 250,  subRolloffEnabled = false, subRolloffFreq = null, subRolloffSlope = defaultSlope, lpf4lfeValue = null;

function toggleExpertDrawer() {
  const drawer = document.getElementById('expertDrawer');
  drawer.classList.toggle('open');}
async function floatsToBase64(floatArray) {
    const nativeFloat32Data = (floatArray instanceof Float32Array) ? floatArray : new Float32Array(floatArray);
  if (nativeFloat32Data.length === 0) {
    console.warn("Attempting to Base64 encode an empty array!");
    return "";
  }
  const buffer = new ArrayBuffer(nativeFloat32Data.byteLength);
  const dataView = new DataView(buffer);
  for (let i = 0; i < nativeFloat32Data.length; i++) dataView.setFloat32(i * 4, nativeFloat32Data[i], false);
  const bigEndianUint8Array = new Uint8Array(buffer);
  return new Promise((resolve, reject) => {
    const blob = new Blob([bigEndianUint8Array], { type: 'application/octet-stream' });
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.error) {
        console.error("FileReader error:", reader.error);
        return reject(new Error("FileReader failed to read blob."));
      }
      if (typeof reader.result === 'string') {
        try {
          const base64 = reader.result.split(',', 2)[1];
          if (base64 === undefined) {
             reject(new Error("Could not extract Base64 string from FileReader result."));
          } else {
             resolve(base64);
          }
        } catch (e) {
          console.error("Error processing FileReader result:", e);
          reject(new Error("Failed to process FileReader result."));
        }
      } else {
        reject(new Error("FileReader did not return a string result."));
      }
    };
    reader.onerror = (error) => {
        console.error("FileReader onerror:", error);
        reject(error);
    };
    reader.readAsDataURL(blob);
  });}
async function sendImpulseToRew(impulseData) {
  const rewEndpoint = 'http://localhost:4735/import/impulse-response-data';
  try {
    const response = await fetch(rewEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(impulseData),
    });
    if (!response.ok) {
       let errorMsg = `REW API Error: ${response.status} ${response.statusText}`;
       let responseBodyText = '';
       try { responseBodyText = await response.text(); } catch(e){}
       errorMsg += ` - ${responseBodyText}`;
       if (responseBodyText.includes("Too many impulse response imports pending")) {
            console.warn(`>>> REW queue is full (received error status ${response.status} for "${impulseData.identifier}"). Increase loop delay! <<<`);
       }
       throw new Error(errorMsg);
    }
    const body = await response.json();
    return true;
  } catch (error) {
    console.error(`Failed to send data to REW for "${impulseData.identifier}".`, error);
    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
        throw new Error(`Network error: Could not connect to REW API at ${rewEndpoint}.`);
    }
    throw error;
  }}
async function extractMeasurements() {
  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
  await clearCommands();
  await updateAPI('inhibit-graph-updates', false);
  await updateAPI('blocking', true);
  await updateAPI('inhibit-graph-updates', true);
  let jName, jType, jData;
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.ady, .mqx';
  const file = await new Promise((resolve) => {
    input.addEventListener('change', function (event) {
      resolve(event.target.files[0]);
    });
    input.click();
  });
  if (!file) {
    console.info('No file selected.');
    return;
  }
  jName = file.name;
  jType = jName.split('.').pop();
  console.info(`Extracting measurements from ${jName}...`);
  try {
    jData = await inputFile(file);
  } catch (error) {
    console.error(`Error parsing file ${jName}: ${error.message}`);
    throwError(`Failed to parse the input file. Ensure it's a valid ${jType} JSON file.`);
    return;
  }
  let inv_micCal;
  let splOffset;
  const sampleRate = 48000;
  const startTime = 0.0;
  const responseLength = 16384;
  const applyMicCal = isCirrusLogic || jType === "mqx";
  if (applyMicCal) {
    console.info(`Applying AC1HB microphone calibration adjustment to each measurement...`);
    if (!micCalFile || micCalFile.length === 0) {
        console.error("Microphone calibration file (micCalFile) is missing or empty.");
        throwError("Microphone calibration data is not available.");
        return;
    }
    try {
        let perfectResponse = [1, ...Array(responseLength - 1).fill(0)];
        inv_micCal = vectorDivide(perfectResponse, micCalFile);
        splOffset = 95.0;
    } catch (error) {
        console.error("Error preparing microphone calibration:", error);
        throwError("Failed to calculate inverse microphone calibration.");
        return;
    }
  } else {
    splOffset = 75.0;
  }
  let totalMeasurementsSent = 0;
  let hasSubwoofer = false;
  let rewConnectionFailed = false;
  const REW_PROCESSING_DELAY_MS = 35;
  const processMeasurements = async () => {
    const measurementProcessors = {
      ady: async () => {
        const { detectedChannels } = jData;
        for (const [key, detectedChannel] of Object.entries(detectedChannels)) {
          const {responseData, commandId} = detectedChannel;
          if (commandId && commandId.startsWith("SW")) {
            hasSubwoofer = true;
          }
          for (const [arrayKey, arrayData] of Object.entries(responseData)) {
            if (rewConnectionFailed) continue;
            const measurementName = `${commandId}${arrayKey}`;
            try {
              let finalData = arrayData;
              if (isCirrusLogic && applyMicCal) {
                 if (!inv_micCal) throw new Error("Inverse mic calibration data not available for ADY processing.");
                 finalData = await fastConvolution(arrayData, inv_micCal);
                 if (finalData.length > responseLength) {
                    finalData = finalData.slice(0, responseLength);
                 } else if (finalData.length < responseLength) {
                    finalData = finalData.concat(Array(responseLength - finalData.length).fill(0));
                 }
              }
              const float32Data = (finalData instanceof Float32Array) ? finalData : new Float32Array(finalData);
              const base64Data = await floatsToBase64(float32Data);
              const impulsePayload = {identifier: measurementName, startTime: startTime, sampleRate: sampleRate, splOffset: splOffset, applyCal: false, data: base64Data};
              await sendImpulseToRew(impulsePayload);
              totalMeasurementsSent++;
              await delay(REW_PROCESSING_DELAY_MS);
            } catch (error) {
              console.error(`Error processing or sending ${measurementName}:`, error.message);
              if (error.message.includes("Network error") || error.message.includes("REW API Error")) rewConnectionFailed = true;
            }
            if (rewConnectionFailed) break;
          }
        }
      },
      mqx: async () => {
        const { _measurements: measurements, _channelDataMap, CalibrationSettings } = jData;
        const { DistancePoisitionGuid, TrimPositionGuids } = CalibrationSettings;
        const positionIndices = {};
        let globalIndex = 1;
        const subwooferMap = {
          SW1: ["SWF", "SWL", "SWFL"], SW2: ["SWR", "SWFR", "SWB"], SW3: ["SWBL"], SW4: ["SWBR"]};
        const tempSubMap = {};
        measurements.forEach((measurement) => {
          const {ChannelGuid} = measurement;
          const avrOriginatingDesignation = _channelDataMap[ChannelGuid]?.Metadata?.AvrOriginatingDesignation || "";
          if (avrOriginatingDesignation.startsWith("SW")) {
            for (const [swKey, aliases] of Object.entries(subwooferMap)) {
              if (aliases.includes(avrOriginatingDesignation)) {
                tempSubMap[avrOriginatingDesignation] = swKey;
              }
            }
          }
        });
        const allSWChannels = Object.keys(tempSubMap);
        if (allSWChannels.includes("SWB")) {
          if (allSWChannels.includes("SWF") && !allSWChannels.includes("SWR")) {
            tempSubMap["SWB"] = "SW2";
          } else if (allSWChannels.includes("SWFL") && allSWChannels.includes("SWFR")) {
            tempSubMap["SWB"] = "SW3";
          }
        }
        if (!inv_micCal) {
             throw new Error("Inverse mic calibration data not available for MQX processing.");
        }
        for (const measurement of measurements) {
          if (rewConnectionFailed) continue;
          const { Data, PositionGuid, ChannelGuid } = measurement;
          let measurementName = "Unknown";
          try {
            let avrOriginatingDesignation = _channelDataMap[ChannelGuid]?.Metadata?.AvrOriginatingDesignation || "Unknown";
            if (avrOriginatingDesignation.startsWith("SW")) {
              avrOriginatingDesignation = tempSubMap[avrOriginatingDesignation] || avrOriginatingDesignation;
              hasSubwoofer = true;
            }
            let positionIndex;
            const isZeroGuid = DistancePoisitionGuid === "00000000-0000-0000-0000-000000000000";
            if ((!isZeroGuid && PositionGuid === DistancePoisitionGuid) || (isZeroGuid && PositionGuid === TrimPositionGuids[0])) {
              positionIndex = 0;
            } else if (positionIndices[PositionGuid] !== undefined) {
              positionIndex = positionIndices[PositionGuid];
            } else {
              positionIndex = globalIndex++;
              positionIndices[PositionGuid] = positionIndex;
            }
            measurementName = `${avrOriginatingDesignation}${positionIndex}`;
            const bytes = Uint8Array.from(atob(Data), (c) => c.charCodeAt(0));
            const dataView = new DataView(bytes.buffer);
            const floats = new Float32Array(bytes.length / 4);
             for (let i = 0; i < floats.length; i++) {
                 floats[i] = dataView.getFloat32(i * 4, true);
             }
            let convolvedData = await fastConvolution(Array.from(floats), inv_micCal);
             if (convolvedData.length > responseLength) {
                 convolvedData = convolvedData.slice(0, responseLength);
             } else if (convolvedData.length < responseLength) {
                 convolvedData = convolvedData.concat(Array(responseLength - convolvedData.length).fill(0));
             }
            const base64Data = await floatsToBase64(convolvedData);
            const impulsePayload = {identifier: measurementName, startTime: startTime, sampleRate: sampleRate, splOffset: splOffset, applyCal: false, data: base64Data};
            await sendImpulseToRew(impulsePayload);
            totalMeasurementsSent++;
              console.log(`--- Waiting ${REW_PROCESSING_DELAY_MS}ms for REW to process ${measurementName}... ---`);
              await delay(REW_PROCESSING_DELAY_MS);
          } catch (error) {
            console.error(`Error processing or sending measurement ${measurementName} (ChannelGuid: ${ChannelGuid}):`, error.message);
             if (error.message.includes("Network error") || error.message.includes("REW API Error")) rewConnectionFailed = true;
          }
        }
      }
    };
    await measurementProcessors[jType] ();
    if (!hasSubwoofer) throw new Error("No subwoofer channels found in the uploaded calibration file. A subwoofer is required.");
    if (rewConnectionFailed) throw new Error("Failed to send one or more measurements to REW. Please check REW connection and console logs.");
  };
  function showLogPopup(message) {
  let popup = document.getElementById('log-popup');
  if (!popup) {
    popup = document.createElement('div');
    popup.id = 'log-popup';
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #f9f9f9; /* Light background */
      color: #333; /* Dark text for better contrast */
      padding: 20px;
      border: 1px solid #ddd; /* Lighter border */
      border-radius: 8px; /* More rounded corners */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Softer shadow */
      max-width: 80%;
      max-height: 80%;
      overflow: auto;
      z-index: 1000;
      font-family: sans-serif; /* Use a readable sans-serif font */
      font-size: 16px; /* Slightly larger font size */
      line-height: 1.5; /* Improved line height for readability */
    `;
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = `
      display: block;
      margin-top: 15px; /* More space above the button */
      padding: 8px 15px; /* Better button padding */
      background-color: #4CAF50; /* Green button */
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    `;
    closeBtn.onclick = () => popup.style.display = 'none';
    const content = document.createElement('div');
    content.id = 'log-popup-content';
    content.style.whiteSpace = 'pre-wrap';
    popup.appendChild(content);
    popup.appendChild(closeBtn);
    document.body.appendChild(popup);
  }
  const content = document.getElementById('log-popup-content');
  content.innerHTML += message + '\n';
  popup.style.display = 'block';
}
  try {
      await processMeasurements();
      showLogPopup(`Successfully extracted ${totalMeasurementsSent} measurements to REW!`);
      await updateAPI('inhibit-graph-updates', false);
      const fileName = jName.slice(0, -4) + ".mdat";
      const fullPath = `${localAppPath}/${fileName}`;
      await postSafe(`http://localhost:4735/measurements/command`, {command: 'Save all', parameters: [fullPath]}, `Saved all measurements`);
      showLogPopup(`Extracted measurements saved as: ${fileName} to folder: ${fullPath}`);
  } catch (error) {
      console.error("Measurement extraction and sending failed:", error.message);
      throwError(error.message || "An unexpected error occurred during measurement processing.");
  } finally {
      if (inv_micCal && inv_micCal.length > 0) inv_micCal.length = 0;
  }}
async function inputFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = function (e) {
      try {
        const data = JSON.parse(e.target.result);
        resolve(data);
      } catch (error) {
        reject(new Error('Error parsing JSON: ' + error.message));
      }
    };
    reader.onerror = function () {
      reject(new Error('Error reading file: ' + reader.error.message));
    };
    reader.readAsText(file);
  });}
async function checkOrigin(){
  const response = await fetchSafe('impulse-response', 1);
  const bytes = Uint8Array.from(atob(response.data), c => c.charCodeAt(0));
  const totalSamples = bytes.length / 4;
  return (totalSamples < 32768);}
async function checkPrePro() {
  const first = await fetchREW(1);
  const note = first.notes;
  return note === 'pre-processsed measurement';}
async function checkAutomatedMeasurements(){
  console.info(`Checking consistency of imported measurements...`);
  let allResponses = await fetchREW();
  const titleIndices = {};
  let nTotal = Object.keys(allResponses).length;
  if (nTotal > 500) {
    console.error(`Acoustica cannot process more than 500 measurements at this time. You will need to delete some of the mic positions and restart optimization!`);
    throwError();
  }
  if ((nTotal * 2) > rewMaxLimit) {
    console.warn(`You need to increase maximum measurement limit to at least ${nTotal * 2} in REW/Preferences for Acoustica to be able to process all these measurements!`);
    throwError();
  }
  let totalSpeakers = 0;
  let totalSubs = 0;
  for (let i = 1; i <= nTotal; i++) {
    const title = allResponses[i].title;
    if (title.startsWith('SWMIX')) standardBassError();
    if (title.startsWith('SW')) {
      const subNum = parseInt(title[2], 10);
      if (subNum < 1 || subNum > 4) {
        console.error(`Unexpected sub number in title: ${title}`);
        throwError();
      }
      const measurementIndexPart = title.slice(3);
      const measurementIndex = parseInt(measurementIndexPart, 10);
      const baseTitle = 'SW' + subNum;
      if (!titleIndices[baseTitle]) {
          titleIndices[baseTitle] = [];
          totalSubs++;
      }
      titleIndices[baseTitle].push(measurementIndex);
    } else {
      const speakerName = title.replace(/\d+$/, '');
      const indexPart = title.match(/(\d+)$/);
      if (!indexPart) {
          console.error(`Speaker measurement '${title}' is missing an index`);
          throwError();
      }
      if (!titleIndices[speakerName]) {
          titleIndices[speakerName] = [];
          totalSpeakers++;
      }
      titleIndices[speakerName].push(parseInt(indexPart[0], 10));
    }
  }
  for (const [name, indices] of Object.entries(titleIndices)) {
    if (!indices.includes(0)) {
      console.error(`Measurement for main listening position (index 0) is missing for ${name}. Optimization cannot proceed without it!`);
      throwError();
    }
  }
  const numberOfIndices = Object.values(titleIndices).map(indices => indices.length);
  const firstLength = numberOfIndices[0];
  if (!numberOfIndices.every(length => length === firstLength)) {
    const inconsistentSpeakers = Object.entries(titleIndices)
      .filter(([_, indices]) => indices.length !== firstLength)
      .map(([name, indices]) => `${name} (${indices.length} measurements)`)
      .join(', ');
    const hasMissingIndices = numberOfIndices.some(length => length < firstLength);
    const hasExtraIndices = numberOfIndices.some(length => length > firstLength);
    if (hasMissingIndices && isCirrusLogic && (inconsistentSpeakers.includes('SW1') && inconsistentSpeakers.includes('SW2'))) {
      console.warn(`** Dual subwoofers measured with cable swap method detected and will be processed accordingly! **`);
    } else if (hasMissingIndices) {
      console.warn(`Some measurements seem to have been removed from REW. ${inconsistentSpeakers} vs ${firstLength} measurements in others.`);
      console.warn(`If this was NOT intentional, you should reload your original automated measurement results to REW and restart optimization!`);
    }
    if (hasExtraIndices) {
      console.warn(`⚠ Expected ${firstLength} measurements but found extra counts in: ${inconsistentSpeakers}`);
      console.warn(`If this was NOT intentional, you should reload your original automated measurement results to REW and restart optimization!`);
    }
  }
  console.info(`Preparing measurement layout for optimization...`);
  if(nTotal > 50) console.warn('This will take a while due to the number of measurements you have uploaded, please be patient!')
  function naturalStringCompare(a, b) {
     return a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'});
  }
  allResponses = await fetchREW();
  let measurementArray = Object.keys(allResponses)
    .map(key => ({
      index: parseInt(key),
      title: allResponses[key].title
    }));
  measurementArray.sort((a, b) => {
    const specialNames = ["C", "FD", "BD", "SD", "FH", "CH"];
    const titleA = a.title;
    const titleB = b.title;
    const isSpecialA = specialNames.some(name => titleA.startsWith(name));
    const isSpecialB = specialNames.some(name => titleB.startsWith(name));
    const isSWA = titleA.startsWith("SW");
    const isSWB = titleB.startsWith("SW");
    if (isSWA && !isSWB) return 1;
    if (isSWB && !isSWA) return -1;
    if (isSpecialA && !isSpecialB) return 1;
    if (isSpecialB && !isSpecialA) return -1;
    if (isSWA && isSWB) {
      const subA = parseInt(titleA[2], 10);
      const subB = parseInt(titleB[2], 10);
      if (subA !== subB) return subA - subB;
      const measA = parseInt(titleA.slice(3), 10) || 0;
      const measB = parseInt(titleB.slice(3), 10) || 0;
      return measA - measB;
    }
    if (isSpecialA && isSpecialB) {
      return naturalStringCompare(titleA, titleB);
    }
    return naturalStringCompare(titleA, titleB);
  });
  let newIndex = nTotal + 1;
  for (const measurement of measurementArray) {
    const {index, title} = measurement;
    await postSafe(`${baseUrl}/${index}/command`, {command: "Response copy"}, "Completed");
    await fetchREW(newIndex, 'PUT', {title: title});
    newIndex++;
  };
  for (let i = nTotal; i >= 1; i--) {
    console.infoUpdate(`Clean up in progress...${(100 - (i - 1) / nTotal * 100).toFixed(2)}%`);
    await postDelete(i);
  }
  const title = measurementArray[measurementArray.length - 1].title;
  const match = title.match(/^SW(\d)/);
  const numSub = parseInt(match[1], 10);
  if (numSub < jsonContent.subwooferNum) standardBassError();
  function standardBassError() {
    console.warn(`⚠ Imported measurements in REW are missing data for each of the ${jsonContent.subwooferNum} subwoofers in your system!`);
    if (isCirrusLogic) {
      console.warn(`Try manually measuring each of your subwoofers with REW and a calibration microphone and RCA cable swapping method`);
    } else {
        if (sOs === 343) {
          console.warn(`Repeat measurement process with your receiver in 'directional bass' mode.`);
        } else {
          console.warn(`Repeat measurement process taking individual measurements for each subwoofer.`);
        }
    }
    console.error(`A1 Evo Acoustica cannot optimize your system without individual measurements for each subwoofer!`);
    throwError();
  }}
async function checkRewMeasurements(){
  function naturalStringCompare(a, b) {return a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'});}
  let firstSWIndex = jsonContent.detectedChannels.findIndex(ch => ch.commandId.startsWith("SW"));
  if (firstSWIndex !== -1) {
    let swCount = 1;
    let chType;
    if (jsonContent.enMultEQType < 2) {
        jsonContent.detectedChannels[firstSWIndex].commandId = `SW1`;
        chType = parseInt(jsonContent.detectedChannels[firstSWIndex].enChannelType);
        jsonContent.detectedChannels[firstSWIndex].enChannelType = chType;
    } else {
        chType = 54;
        for (let i = firstSWIndex; i < jsonContent.detectedChannels.length; i++) {
          jsonContent.detectedChannels[i].commandId = `SW${swCount}`;
          jsonContent.detectedChannels[i].enChannelType = chType;
          swCount++;
          chType++;
        }
    }
  } else {
      console.error("No subwoofers detected in the uploaded configuration file. A1 Evo cannot optimize systems with no subwoofers!");
      throwError();
  }
  console.info(`Organizing measurements in REW...`)
  const configuredSpeakers = Object.entries(jsonContent.detectedChannels)
      .map(([_, channel]) => channel.commandId)
      .filter(id => id);
  const subwooferCount = configuredSpeakers.filter(name => name.startsWith('SW')).length;
  let allowedNames = new Set([
    ...configuredSpeakers.filter(name => !name.startsWith('SW')),
    ...Array.from({length: subwooferCount }, (_, i) => `SW${i + 1}`)
  ]);
  let allResponses = await fetchREW();
  let nTotal = Object.keys(allResponses).length;
   if (nTotal > 500) {
    console.error(`Acoustica cannot process more than 500 measurements at this time. You will need to delete some of the mic positions and restart optimization!`);
    throwError();
  }
  if ((nTotal * 2) > rewMaxLimit) {
    console.error(`You need to increase maximum measurement limit to at least ${nTotal * 2} in REW/Preferences for Acoustica to be able to process all these measurements!`);
    throwError();
  }
  let measurementArray = Object.keys(allResponses).map(key => ({
      index: parseInt(key),
      title: allResponses[key].title
  }));
  let invalidNames = [];
  let foundNames = new Set();
  for (let measurement of measurementArray) {
    const title = measurement.title;
    let matchedName;
    if (
      allowedNames.has("CH") &&
      (title === "CH" || title.startsWith("CH ") || title.match(/^CH\d+$/))) {
      matchedName = "CH";
    } else {
      matchedName = Array.from(allowedNames).find((name) => title.startsWith(name) || (name.startsWith("SW") && title.match(new RegExp(`^${name}\\d*$`))));
    }
    if (!matchedName) {
      invalidNames.push(title);
    } else {
      foundNames.add(matchedName);
    }
  }
  const missingNames = Array.from(allowedNames).filter(name => !foundNames.has(name));
  if (invalidNames.length > 0 || missingNames.length > 0) {
    let errorMsg = [];
    if (invalidNames.length > 0) {errorMsg.push("Invalid measurement names detected:\n" + invalidNames.join("\n"));}
    if (missingNames.length > 0) {errorMsg.push("Missing measurements for the following speakers:\n" + missingNames.join("\n"));}
    if (errorMsg.length > 0) {console.error(errorMsg.join("\n\n")); throwError();}
  }
  const nameCounts = {};
  for (const measurement of measurementArray) {
    const {index, title} = measurement;
    if (allowedNames.has('CH') && (title === 'CH' || title.startsWith('CH ') || /^CH\d+$/.test(title))) {
      if (!nameCounts['CH']) {nameCounts['CH'] = 0;}
      const newTitle = `CH${nameCounts['CH'] === 0 ? '0' : nameCounts['CH']}`;
      await fetchREW(index, 'PUT', {title: newTitle});
      nameCounts['CH']++;
      continue;
    }
    for (const name of allowedNames) {
      if (title.startsWith(name)) {
        if (!nameCounts[name]) {nameCounts[name] = 0;}
        const newTitle = `${name}${nameCounts[name] === 0 ? '0' : nameCounts[name]}`;
        await fetchREW(index, 'PUT', {title: newTitle});
        nameCounts[name]++;
        break;
      }
    }
  }
  console.info(`Total measurements to process => ${nTotal} :`);
  for (const [name, count] of Object.entries(nameCounts)) {
      console.info(`${name} => ${count}`);
  }
  allResponses = await fetchREW();
  measurementArray = Object.keys(allResponses).map(key => ({
    index: parseInt(key),
    title: allResponses[key].title
  }));
  measurementArray.sort((a, b) => {
    const specialNames = ["C", "FD", "BD", "SD", "FH", "CH"];
    const titleA = a.title;
    const titleB = b.title;
    const isSpecialA = specialNames.some(name => titleA.startsWith(name));
    const isSpecialB = specialNames.some(name => titleB.startsWith(name));
    const isSWA = titleA.startsWith("SW");
    const isSWB = titleB.startsWith("SW");
    if (isSWA && !isSWB) return 1;
    if (isSWB && !isSWA) return -1;
    if (isSpecialA && !isSpecialB) return 1;
    if (isSpecialB && !isSpecialA) return -1;
    if (isSWA && isSWB) {
      const subA = parseInt(titleA[2], 10);
      const subB = parseInt(titleB[2], 10);
      if (subA !== subB) return subA - subB;
      const measA = parseInt(titleA.slice(3), 10) || 0;
      const measB = parseInt(titleB.slice(3), 10) || 0;
      return measA - measB;
    }
    if (isSpecialA && isSpecialB) {
      return naturalStringCompare(titleA, titleB);
    }
    return naturalStringCompare(titleA, titleB);
  });
  for (let i = 0; i < measurementArray.length; i++) {
    const measurement = measurementArray[i];
    const {index, title} = measurement;
    await postNext("Trim IR to windows", index);
    await new Promise((resolve) => setTimeout(resolve, speedDelay / 5));
    const progress1 = ((i + 1) / measurementArray.length) * 100;
    console.infoUpdate(`Processing ${progress1.toFixed(2)}% completed`);
    await fetchREW(nTotal +  i + 1, 'PUT', {title: title});
  }
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  for (let j = nTotal; j >= 1; j--) {
    await postDelete(j);
    await new Promise((resolve) => setTimeout(resolve, speedDelay / 5));
    const progress2 = ((nTotal - j + 1) / nTotal) * 100;
    console.infoUpdate(`Clean up ${progress2.toFixed(2)}% completed`);
  }}
async function main(){
  const logContainer = document.getElementById('logContainer');
  const measurementChoice = document.getElementById('measurementChoice');
  logContainer.style.display = 'block';

  document.body.style.overflow = 'hidden';

  measurementChoice.classList.add('transitioned');
  const startTime = performance.now();
  console.infoBold(`** Customizations start **`);
  const defaults = {subBoost: 0, bassFill: 0, levelLowVol: 2, enableInversion: false, enableWeakBass: false, noAllpass: false, minFreq: 40, maxFreq: 250, minFreqFR: 40, maxFreqFR: 250, minFreqC: 40, maxFreqC: 250};
  const customizations = {subBoost, bassFill, levelLowVol, enableInversion, enableWeakBass, noAllpass, minFreq, maxFreq, minFreqFR, maxFreqFR, minFreqC, maxFreqC};
  const descriptions = {
    subBoost: `Subwoofer EQ filters maximum allowed boost (dB): `,
    bassFill: `Subwoofer target curve infill value (dB): `,
    levelLowVol: `Low volume listening level offset (dB): `,
    enableInversion: `Out of phase 'Speaker' detection and automatic inversion? `,
    enableWeakBass: `Applied SPL offset fix to subwoofer measurements? `,
    noAllpass: `Allpass filters enabled? `,
    minFreqFR: `Minimum searchable crossover frequency - front mains: `,
    maxFreqFR: `Maximum searchable crossover frequency - front mains: `,
	  minFreqC: `Minimum searchable crossover frequency - center speaker: `,
    maxFreqC: `Maximum searchable crossover frequency - center speaker: `,
    minFreq: `Minimum searchable crossover frequency - all other speakers: `,
    maxFreq: `Maximum searchable crossover frequency - all other speakers: `
  };
  for (let key in customizations) {
    let displayValue = customizations[key];
    if (key === 'levelLowVol') displayValue = dbValues[displayValue];
    const message = `${descriptions[key]}${displayValue}${key === 'levelLowVol' ? ' dB' : ''}`;
    if (customizations[key] !== defaults[key]) {console.warn(message);} else {console.log(message);}
  }
  if (subRolloffEnabled) {
    console.warn(`Acoustica will not calculate subwoofer roll off frequencies and force '${subRolloffSlope}' high-pass filter @ ${subRolloffFreq}Hz & 'L-R4 (hardware fixed) @ ${lpf4lfeValue}Hz`);
  }
  console.infoBold(`** Customizations end **`);
  await checkREW();
  await clearCommands();
  await updateAPI('blocking', true);
  await updateAPI('inhibit-graph-updates', true);
  isAutomated = await checkOrigin();
  isPreProcessed = await checkPrePro();
  isAutomated ? console.log("<< Optimizing using 'automated' measurements with 16k samples >>") : console.log("<< Optimizing using 'manual REW' measurements with 256k samples >>");
  if (!isPreProcessed) {
    isAutomated ? await checkAutomatedMeasurements() : await checkRewMeasurements()
    await resetAll();
    if (!isAutomated) await fixSubs4REW();
    await ocAced();
  } else {
    console.log('<< Using previously processed and saved measurements >>');
  }
  await secondary();
  await setVolumeLevels();
  await sortBass();
  await refResults();
  await lowVolumeFilters();
  const endTime = performance.now();
  const totalTime = (endTime - startTime) / 1000;
  const formatTime = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.round(seconds % 60);
    if (minutes === 0) {
      return `${remainingSeconds} second${remainingSeconds !== 1 ? 's' : ''}`;
    } else if (remainingSeconds === 0) {
      return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
    } else {
      return `${minutes} minute${minutes !== 1 ? 's' : ''} and ${remainingSeconds} second${remainingSeconds !== 1 ? 's' : ''}`;
    }
  };
  const getCurrentDateTime = () => {
    const now = new Date();
    return now.toLocaleString('en-US', {year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true});
  };
  console.infoBold(`'A1 Evo Acoustica' completed optimization of your system in ${formatTime(totalTime)} on ${getCurrentDateTime()}.`);
  const oceFilename = await generateOCA();
  console.warn(`Please return to main application and transfer saved calibration file (.oca) to your receiver using option '3'`);
  console.log(`You can view the original and optimized (final) responses of your system's speakers and subwoofers, along with the applied filters (filter), in REW 'All SPL' tab`);
  console.log(`You can find a copy of the full log of this optimization in the application folder with the same name as the optimization file with '.html' extension`)
  console.log(`Optimal settings for loud / normal listening volume levels will be active in 'Flat' mode`);
  console.log(`'Reference' mode can be used for low volume / late night listening.`);
  console.infoBold(`Enjoy your 'Evo'lved sound!`);
  console.infoBold(`OCA`);
  await updateAPI('blocking', false);
  await updateAPI('inhibit-graph-updates', false);}
async function checkREW() {
  try {
    await postSafe(`http://localhost:4735/eq/default-equaliser`, {manufacturer: "Generic", model: "Generic"}, "Default equaliser changed");
  } catch (error) {
    console.error("Error while setting default equaliser. Please ensure the REW API server is running.");
    throwError("Could not connect to the REW API server. Please start it from 'REW/Preferences/API/Start server' and try again.");
  }
  let dontStart = true, reTry = 10, versionString;
  do {
    try {
      const rewVersionResponse = await fetch(`http://localhost:4735/version`);
      if (rewVersionResponse.ok) {
        const rewData = await rewVersionResponse.json();
        versionString = rewData.message;
        const versionMatch = versionString.match(/(\d+)\.(\d+)\sBeta\s(\d+)/);
        const major = parseInt(versionMatch[1], 10);
        const minor = parseInt(versionMatch[2], 10);
        const beta = parseInt(versionMatch[3], 10);
        const versionOK = major > 5 || (major === 5 && minor > 40) || (major === 5 && minor === 40 && beta >= 84);
        if (!versionOK) {
          console.error(`Installed REW version (${versionString}) is outdated and incompatible with A1 Evo! Please install the latest REW Beta from https://www.avnirvana.com/threads/rew-api-beta-releases.12981/.`);
          throwError();
        }
      } else {
        console.warn(`⚠ REW API server is not responding. Retrying in ${reTry} seconds...`);
        await new Promise((resolve) => setTimeout(resolve, reTry * 1000));
        reTry = (reTry % 5) + 1;
        continue;
      }
      const measurements = await fetchREW();
      const emptyMeasurements = !measurements || Object.keys(measurements).length === 0;
      rewMaxLimit = await fetchSafe('max-measurements');
      const limitExceeded = rewMaxLimit < 200;
      const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
      if (tcResponse.ok) {
        const responseText = await tcResponse.text();
        if (!responseText.trim()) {
            targetCurvePath = null;
        } else {
            targetCurvePath = responseText.trim();
            if (targetCurvePath.startsWith('"') && targetCurvePath.endsWith('"')) {
                targetCurvePath = targetCurvePath.slice(1, -1);
            }
            if (!targetCurvePath) {
                targetCurvePath = null;
            }
        }
      } else {
          targetCurvePath = null;
      }
      targetCurvePath = targetCurvePath ? `"${targetCurvePath}"` : null;
      const missingTargetCurve = !targetCurvePath;
      if (emptyMeasurements || limitExceeded || missingTargetCurve) {
        if (emptyMeasurements) {
          console.warn(`⚠ No measurements in REW. Please load measurements. Retrying in ${reTry} seconds...`);
        }
        if (limitExceeded) {
          console.warn(`⚠ Max number of measurements REW can handle is set too low (${rewMaxLimit}). Please set it to 200 or above (limit 1000) in "REW/Preferences/View/Maximum measurements". Retrying in ${reTry} seconds...`);
        }
        if (missingTargetCurve) {
          console.warn(`⚠ Target curve not found. Please upload your preferred target curve under "REW/EQ/Target settings/House curve". Retrying in ${reTry} seconds...`);
        }
        await new Promise((resolve) => setTimeout(resolve, reTry * 1000));
        reTry = (reTry % 5) + 3;
      } else {
        dontStart = false;
      }
    } catch (error) {
      console.warn(`⚠ Error connecting to REW API server: ${error.message}`);
      console.warn(`Please start the API server from "REW/Preferences/API/Start server". Retrying in ${reTry} seconds...`);
      await new Promise((resolve) => setTimeout(resolve, reTry * 1000));
      reTry = (reTry % 5) + 1;
    }
  } while (dontStart);
  console.info(`Using REW version: ${versionString}`);
  console.info(`Total number of measurements allowed in REW: ${rewMaxLimit}`);
  console.info(`Optimizing for user uploaded target curve: ${targetCurvePath}`);
  console.info(`Active optimizer: A1 Evo Acoustica ${evoVersion}`);}
async function resetAll(){
  await postSafe(`http://localhost:4735/eq/default-equaliser`, {manufacturer: "Generic", model: "Generic"}, "Default equaliser changed");
  await postSafe(`http://localhost:4735/eq/default-room-curve-settings`, {addRoomCurve: false}, "Update processed");
  await postSafe(`http://localhost:4735/eq/default-target-settings`, {shape: "None"}, "Update processed");
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  let allResponses = await fetchREW();
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  let nTotal = Object.keys(allResponses).length;
  for (let i = 1; i <= nTotal; i++) {
    console.infoUpdate(`Resetting IR windows, smoothing, EQ type, target shape and room curve settings...${(i / nTotal * 100).toFixed(2)}%`);
    await postNext('Smooth', i, {smoothing: "None"});
    await new Promise((resolve) => setTimeout(resolve, speedDelay / 10));
    await postSafe(`${baseUrl}/${i}/ir-windows`, {leftWindowType: "Rectangular", rightWindowType: "Rectangular", addFDW: false}, "Update processed");
    await new Promise((resolve) => setTimeout(resolve, speedDelay / 10));
    await postSafe(`${baseUrl}/${i}/target-settings`, {shape: "None"}, "Update processed");
    await new Promise((resolve) => setTimeout(resolve, speedDelay / 10));
    await postSafe(`${baseUrl}/${i}/room-curve-settings`, {addRoomCurve: false}, "Update processed");
    await new Promise((resolve) => setTimeout(resolve, speedDelay / 10));
    await postSafe(`${baseUrl}/${i}/equaliser`, {manufacturer: "Generic", model: "Generic"}, "Equaliser selected");
    await new Promise((resolve) => setTimeout(resolve, speedDelay / 10));
  }}
async function ocAced() {
 const allowedNames = ['FL','FR','C','SLA','SRA','SBL','SBR','SB','FHL','FHR','FWL','FWR','TFL','TFR','TML','TMR','TRL','TRR','RHL','RHR','FDL','FDR','SDL','SDR','BDL','BDR','SHL','SHR','TS','CH','SW1','SW2','SW3','SW4'];
  function extractBaseName(title) {
    let bestMatch = null;
    let bestMatchLength = 0;
    for (const name of allowedNames) {
      if (title.startsWith(name) && name.length > bestMatchLength) {
        bestMatch = name;
        bestMatchLength = name.length;
      }
    }
    return bestMatch !== null ? bestMatch : title;
  }
  let allResponses = await fetchREW();
  let measurementArray = Object.keys(allResponses).map(key => ({
    index: parseInt(key, 10),
    title: allResponses[key].title,
  }));
  let currentGroup = [measurementArray[0].index];
  let currentPrefix = extractBaseName(measurementArray[0].title);
  let isSubwooferGroup = currentPrefix.startsWith('SW');
  let hasMultipleMeasurements = false;
  let anyMultipleMeasurements = false;
  for (let i = 1; i < measurementArray.length; i++) {
    const {index, title} = measurementArray[i];
    const prefix = extractBaseName(title);
    const isCurrentSubwooferGroup = prefix.startsWith('SW');
    if (prefix !== currentPrefix) {
      if (!isSubwooferGroup && currentGroup.length > 1) {
        if (!hasMultipleMeasurements) {
          console.info(`Performing IDW analysis on speaker measurements based on mic position proximity to MLP...`);
          hasMultipleMeasurements = true;
        }
        anyMultipleMeasurements = true;
        await syncPeaks(currentGroup, currentPrefix);
      }
      await getSpatial(currentGroup, currentPrefix);
      currentGroup = [index];
      currentPrefix = prefix;
      isSubwooferGroup = isCurrentSubwooferGroup;
    } else {
      currentGroup.push(index);
    }
  }
  if (currentGroup.length > 0) {
    if (!isSubwooferGroup && currentGroup.length > 1) await syncPeaks(currentGroup, currentPrefix);
    await getSpatial(currentGroup, currentPrefix);
  }
  console.info(`Clean up in progress...`);
  for (let i = measurementArray.length; i > 0; i--) await postDelete(i);
  if (anyMultipleMeasurements) {
    await putSafe(`${baseUrl}/1`, {notes: 'pre-processsed measurement'},'Update processed');
    const modalHtml = `
      <dialog style="
        /* Match #logContainer's look */
        background: linear-gradient(135deg, #2D3748, #4A5568);
        padding: 20px;
        border-radius: 10px;
        border: none;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        max-width: 800px;
        font-family: 'Poppins', 'Segoe UI', Roboto, sans-serif;
        font-size: 0.8rem;
        color: #E2E8F0;
        z-index: 3000; 
      ">
        <form method="dialog" style="margin: 0;">
          <h3 style="
            margin: 0 0 15px 0; 
            font-size: 1.5rem; 
            font-weight: bold; 
            color: #E2E8F0;
          ">
            Save Progress?
          </h3>
          <p style="
            margin-bottom: 20px; 
            line-height: 1.6; 
            color: #E2E8F0;
          ">
            Multiple microphone positions were processed. Would you like to save the current state to avoid redundant processing in future optimization runs? REW file 
            <strong>'Pre-processed_Measurements_[timestamp].mdat'</strong> 
            will be saved in the 'A1 Evo Acoustica' folder.
          </p>
          <div style="display: flex; justify-content: flex-end; gap: 10px;">
            <!-- Cancel Button -->
            <button type="submit" value="cancel" style="
              padding: 10px 20px; 
              border: none; 
              border-radius: 6px; 
              background: #4A5568; 
              color: #E2E8F0; 
              font-size: 0.8rem; 
              cursor: pointer; 
              transition: background 0.2s ease;
            ">
              Cancel
            </button>
            <!-- Save Button -->
            <button type="submit" value="confirm" style="
              padding: 10px 20px; 
              border: none; 
              border-radius: 6px; 
              background: #2B6CB0; 
              color: #E2E8F0; 
              font-size: 0.8rem; 
              font-weight: bold; 
              cursor: pointer; 
              transition: background 0.2s ease;
            ">
              Save
            </button>
          </div>
        </form>
      </dialog>
    `;
    const wrapper = document.createElement('div');
    wrapper.innerHTML = modalHtml;
    const dialog = wrapper.querySelector('dialog');
    const styleElem = document.createElement('style');
    styleElem.innerHTML = `
      dialog::backdrop {
        background: rgba(0, 0, 0, 0.6); 
        backdrop-filter: blur(2px);
      }
    `;
    document.head.appendChild(styleElem);
    document.body.appendChild(dialog);
    dialog.showModal();
    const result = await new Promise(resolve => {
      dialog.addEventListener('close', () => {
        const returnValue = dialog.returnValue;
        resolve(returnValue === 'confirm');
        dialog.remove();
      });
    });
    if (result) {
      try {
        if (!localAppPath) {
           await fetchAppPath();
           if (!localAppPath) throw new Error("Cannot save: Application path is unknown.");
        }
        const now = new Date();
        const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
        const fileName = `Pre-processedMeasurements_${timestamp}.mdat`;
        const fullPath = `${localAppPath}/${fileName}`;
        await postSafe(`http://localhost:4735/measurements/command`, {command: 'Save all', parameters: [fullPath] }, 'Saved all measurements');
        console.log(`${fullPath} saved in the main application folder.`);
      } catch (error) {
          console.error("Error preparing or sending save command:", error);
          alert(`Failed to save measurements via REW: ${error.message}`);
      }
    } else {
        console.log('User chose not to save progress.');
    }
  }}
async function secondary(){
  let allResponses = await fetchREW();
  let measurementArray = Object.keys(allResponses).map(key => ({
    index: parseInt(key),
    title: allResponses[key].title
  }));
  let allSpeakers = Object.keys(allResponses)
    .filter(key => !allResponses[key].title.startsWith("SW"))
    .map(key => parseInt(key));
  nSpeakers = allSpeakers.length;
  let allSubs = Object.keys(allResponses)
    .filter(key => allResponses[key].title.startsWith("SW"))
    .map(key => parseInt(key));
  nSubs = allSubs.length;
  for (let i = 1; i <= nSpeakers + nSubs; i++){
    const readName = await fetchREW(i);
    const name = readName.title;
    commandId[i] = name.slice(0, -1);
    customCrossover[i] = null;
  }
  const detectedChannelIds = jsonContent.detectedChannels.map(channel => channel.commandId);
  commandId.forEach((id, index) => {
    if (!detectedChannelIds.includes(id)) {
      console.error(`Channel ${id} is missing in configuration file!`);
      throwError();
    }
  });
  detectedChannelIds.forEach((id, index) => {
    if (!commandId.includes(id)) {
      console.error(`Channel "${id}" in the uploaded configuration file is missing in REW. Please ensure that the channels are correctly configured in the receiver's 'Speaker Configuration' menu before generating the '.avr' file.`);
      throwError();
    }
  });
  if (enableInversion) {
    await checkPolarity();
  } else {
    customInvert = new Array(nSpeakers + 1).fill(false);
    console.log(`A1 Evo will not be checking speaker polarities!`);
  }
  await syncPeaks(allSpeakers);
  allResponses = await fetchREW();
  allSpeakers.forEach(i => mSec[i] = +allResponses[i].cumulativeIRShiftSeconds);
  let [maxM, minM] = [Math.max(...mSec.slice(1)), Math.min(...mSec.slice(1))];
  modelDelayLimit = maxDistanceLimit / sOs * 1000;
  [hardPositive, hardNegative] = [minM * 1000 + modelDelayLimit, maxM * 1000 - modelDelayLimit];
  if (hardNegative > 0 || hardPositive < 0) {
   console.error(`It's not possible to sync your speakers at the MLP with the available hardware limits of your AVR. You'll need to move these speakers closer and repeat measurements!`);
   throwError();
  }
  allSubs.forEach(i => mSec[i] = +allResponses[i].cumulativeIRShiftSeconds);
  if (nSubs > 1) {
     await multipleSubs(allSubs);
     let [maxSubM, minSubM] = [Math.max(...allSubs.map(i => mSec[i])) * 1000, Math.min(...allSubs.map(i => mSec[i])) * 1000];
     [hardPositive, hardNegative] = [Math.max(hardPositive - maxSubM, hardNegative - minSubM + modelDelayLimit), Math.min(hardNegative - minSubM, hardPositive - maxSubM - modelDelayLimit)];
     if (hardNegative > hardPositive) {
      console.error(`Unfortunately, there's no hardware delay limit left to align your combined subwoofer response with the rest of the speakers! Optimization cannot continue.`);
      throwError();
     }
  } else {
     customInvert[nSpeakers + 1] = false;
     if (enableWeakBass) await postNext('Add SPL offset', nSpeakers + 1, {offset: -10});
  }}
async function syncPeaks(indices, name = null) {
  await postNext('Cross corr align', indices);
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  const response0 = await fetchREW(indices[0]);
  const irStart0 = response0.timeOfIRStartSeconds;
  for (let j = 1; j < indices.length; j++) {
    const ccResponse = await fetchREW(indices[j]);
    const irStartDiff = Math.abs(ccResponse.timeOfIRStartSeconds - irStart0);
    if (irStartDiff > minDistAccuracy) {
      const check = await magicAlign(indices[0], indices[j]);
      if (!check) {continue;}
      const secondTry = await fetchREW(indices[j]);
      const irStartDiff2 = secondTry.timeOfIRStartSeconds - irStart0;
      if (Math.abs(irStartDiff2) > minDistAccuracy && check) {
        if (name) {
          console.warn(`Measurement ${name}${j} required several additional attempts to be properly aligned to MLP due to strong HF reflection content in its IR!`)
          await new Promise((resolve) => setTimeout(resolve, speedDelay));
        }
          else {
            const whatName = await fetchREW(j + 1);
            const title = whatName.title;
            console.warn(`Measurement ${title} required several additional attempts to be properly aligned to MLP due to strong HF reflection content in its IR!`)
            await new Promise((resolve) => setTimeout(resolve, speedDelay));
          }
      }
    }
  }
  async function magicAlign(index0, index1) {
    let magicShift = await getDivisionPeakTime(index0, index1);
    if (Math.abs(magicShift) > minDistAccuracy) {
      await postNext('Offset t=0', index1, {offset: magicShift, unit: "seconds"});
      return true;
    }
    return false;
    async function getDivisionPeakTime(i0, i1) {
      const division = await postNext('Arithmetic', [i1, i0], {function: "A / B"});
      await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
      const key = parseInt(Object.keys(division.results)[0], 10);
      const peakIR = await findTruePeak(key);
      await postDelete(key);
      return peakIR;
    }
  };}
async function findTruePeak(key) {
  const ep = await postNext('Excess phase version', key, {
    "include cal": true,
    "append lf tail": false,
    "append hf tail": false,
    "frequency warping": false,
    "replicate data": false
  });
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  const keyEP = parseInt(Object.keys(ep.results)[0]);
  const response = await fetchSafe('impulse-response?normalised=true', keyEP);
  await postDelete(keyEP);
  const startTime = response.startTime;
  const sampleRate = response.sampleRate;
  const bytes = Uint8Array.from(atob(response.data), c => c.charCodeAt(0));
  const dataView = new DataView(bytes.buffer);
  const totalSamples = bytes.length / 4;
  let maxPeak = 0;
  let maxPosition = 0;
  for (let i = 1; i < totalSamples - 1; i++) {
    const prev = dataView.getFloat32((i - 1) * 4, false);
    const curr = dataView.getFloat32(i * 4, false);
    const next = dataView.getFloat32((i + 1) * 4, false);
    if ((curr > prev && curr > next) || (curr < prev && curr < next)) {
      for (let j = 0; j < 16; j++) {
        const position = i + j / 16;
        const center = Math.floor(position);
        let interpolatedValue = 0;
        for (let k = center - 8; k <= center + 8; k++) {
          if (k >= 0 && k < totalSamples) {
            const x = position - k;
            const sampleValue = dataView.getFloat32(k * 4, false);
            if (x === 0) {
              interpolatedValue += sampleValue;
            } else if (Math.abs(x) <= 8) {
              const px = Math.PI * x;
              const sinc = Math.sin(px) / px;
              const window = 0.5 * (1 - Math.cos(2 * Math.PI * (x / 16)));
              interpolatedValue += sampleValue * sinc * window;
            }
          }
        }
        if (Math.abs(interpolatedValue) > Math.abs(maxPeak)) {
          maxPeak = interpolatedValue;
          maxPosition = position;
        }
      }
    }
  }
  return startTime + maxPosition / sampleRate;}
async function getSpatial(indices, name) {
  const powerFactor = 1.61803398874989;
  if (indices.length === 1) {
    await postSafe(`${baseUrl}/${indices[0]}/command`, {command: 'Response copy'}, 'Completed');
    const allResponses = await fetchREW();
    const nTotal = Object.keys(allResponses).length;
    await putSafe(`${baseUrl}/${nTotal}`, {title: name + "o"},'Update processed');
    return
  }
  if (name.startsWith("SW")) {
    const vectorAverage = await postNext('Vector average', indices);
    await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
    const vectorKey = Object.keys(vectorAverage.results)[0];
    const key = parseInt(vectorKey, 10);
    await putSafe(`${baseUrl}/${key}`, {title: name + "o"},'Update processed');
    console.info(`Total measurements averaged to optimize speaker ${name} steady state response: ${indices.length}`);
    return;
  };
  console.info(`Analysing speaker ${name} measurements...`);
    const count = indices.length;
    const distances = new Array(count);
    const revertDistances = new Array(count);
    const weights = new Array(count);
    for (let i = 0; i < count; i++) {
      const measurement = await fetchREW(indices[i]);
      distances[i] = parseFloat(measurement.cumulativeIRShiftSeconds);
    }
  const mlpShift = distances[0];
  for (let i = 0; i < count; i++) {
    distances[i] = Math.abs(distances[i] - mlpShift);
  }
  const maxDistance = Math.max(...distances);
  const avrgDistance = math.mean(distances);
  if (maxDistance * 34300 < 1) {
    console.info(`Clocking deviations detected among same mic position repeat measurements (±${(maxDistance * 34300).toFixed(2)}cm)`)
    for (let i = 0; i < count; i++) {
      await postNext('Offset t=0', indices[i], {offset: -avrgDistance, unit: 'seconds'});
    }
    console.info(`Measurements were shifted ${(avrgDistance * 34300).toFixed(2)}cm to compensate`)
    const vectorAverage = await postNext('Vector average', indices);
    await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
    const vectorKey = Object.keys(vectorAverage.results)[0];
    const key = parseInt(vectorKey, 10);
    await fetchREW(key, 'PUT', {title: name + "o"});
    console.info(`Total measurements averaged: ${indices.length}`);
    return;
  }
  const maxCopies = Math.round(indices.length * powerFactor / 2);
  weights[0] = maxCopies;
  for (let i = 1; i < count; i++) {
    const normalizedDistance = distances[i] / maxDistance;
    weights[i] = Math.max(1, Math.round(maxCopies * Math.pow(1 - normalizedDistance, powerFactor)));
  }
  const allResponses = await fetchREW();
  const nTotal = Object.keys(allResponses).length;
  x = 1;
  const newIndices = [];
  indices.forEach((idx, i) => {
    for (let j = 0; j < weights[i]; j++) {
      newIndices.push(idx);
      x++;
    }
  });
  console.info(`Maximum detected distance: ${(maxDistance * 34300).toFixed(2)}cm, applied power factor: ${powerFactor.toFixed(2)}, total copies averaged: ${x - 1}`);
  indices.forEach((idx, i) => {
    weights[i] > 1 ? console.info(`  Position ${idx - indices[0]}${idx === indices[0] ? " (MLP)" : ""}: ${weights[i]} copies (distance: ${(distances[i] * 34300).toFixed(2)}cm)`) :
      console.info(`  Position ${idx - indices[0]}${idx === indices[0] ? " (MLP)" : ""}: ${weights[i]} copy (distance: ${(distances[i] * 34300).toFixed(2)}cm)`);
  });
  const vectorAverage = await postNext('Vector average', newIndices);
  await new Promise((resolve) => setTimeout(resolve, speedDelay * 2));
  const vectorKey = Object.keys(vectorAverage.results)[0];
  const key = parseInt(vectorKey, 10);
  await fetchREW(key, 'PUT', {title: name + "o"});}
async function checkPolarity() {
  const testFrequencies = [200, 1000, 12000];
  async function getPhase(index, frequency) {
    await postNext('Unwrap phase', index, {frequency: frequency});
    await new Promise((resolve) => setTimeout(resolve, speedDelay));
    const response = await fetchSafe('frequency-response?smoothing=1%2F1&ppo=96', index);
    const {startFreq, ppo, phase} = response;
    const bytes = Uint8Array.from(atob(phase), c => c.charCodeAt(0));
    const data = new DataView(bytes.buffer);
    const startIndex = Math.floor(Math.log2(20 / startFreq) * ppo);
    const endIndex = Math.ceil(Math.log2(23491.394531 / startFreq) * ppo);
    const numPoints = endIndex - startIndex;
    const phaseArray = Array.from({length: numPoints}, (_, k) => data.getFloat32((k + startIndex) * 4, false));
    return phaseArray;
  }
  function calculateCorrelation(arrayX, arrayY) {
    const n = arrayX.length;
    const meanX = arrayX.reduce((sum, x) => sum + x, 0) / n;
    const meanY = arrayY.reduce((sum, y) => sum + y, 0) / n;
    let numerator = 0;
    let denomX = 0;
    let denomY = 0;
    for (let i = 0; i < n; i++) {
      const diffX = arrayX[i] - meanX;
      const diffY = arrayY[i] - meanY;
      numerator += diffX * diffY;
      denomX += diffX ** 2;
      denomY += diffY ** 2;
    }
    const denominator = Math.sqrt(denomX * denomY);
    return numerator / denominator;
  }
  let invertedCount = 0;
  const total = nSpeakers + nSubs;
  console.infoBold(`Checking speaker polarities >>`)
  for (let i = 1; i <= nSpeakers; i++) {
    customInvert[i] = false;
    await postNext('Minimum phase version', i, {"include cal": true, "append lf tail": false, "append hf tail": false, "frequency warping": false, "replicate data": false});
    await postSafe(`${baseUrl}/${i}/command`, {command: 'Response copy'}, 'Completed');
    await postSafe(`${baseUrl}/${i}/command`, {command: 'Response copy'}, 'Completed');
    await postSafe(`${baseUrl}/${total + 3}/command`, {command: "Invert"}, "Invert completed");
    const correlationResults = [];
    for (const frequency of testFrequencies) {
      await postNext('Cross corr align', [total + 1, total + 2, total + 3]);
      await new Promise((resolve) => setTimeout(resolve, speedDelay));
      const phaseMP = await getPhase(total + 1, frequency);
      const phaseN = await getPhase(total + 2, frequency);
      const phaseInv = await getPhase(total + 3, frequency);
      const normalCorr = calculateCorrelation(phaseMP, phaseN);
      const invCorr = calculateCorrelation(phaseMP, phaseInv);
      correlationResults.push({
        frequency,
        normalCorr,
        invCorr,
        needsInversion: normalCorr < invCorr
      });
    }
    const needsInversion = correlationResults.every(result => result.needsInversion);
    if (needsInversion) {
      console.warn(`⚠ Speaker ${commandId[i]} seems to be out of phase! A1 Evo will automatically INVERT it! DO NOT swap speaker cables!`);
      customInvert[i] = true;
      invertedCount++;
      await postSafe(`${baseUrl}/${i}/command`, {command: "Invert"}, "Invert completed");
    } else {
      const conflictFreqs = correlationResults.filter(r => r.needsInversion).map(r => r.frequency);
      if (conflictFreqs.length > 0) {
        console.log(`Speaker ${commandId[i]} ✓ (Some of the speaker's drivers suggested inversion: ${conflictFreqs.join(', ')}Hz)`);
      } else {
        console.log(`Speaker ${commandId[i]} ✓`);
      }
      customInvert[i] = false;
    }
    await postDelete(total + 3); 
    await postDelete(total + 2); 
    await postDelete(total + 1);
  } 
  if (invertedCount > 0 && invertedCount < nSpeakers) {
    console.warn(`False polarity warnings may occur due to measurement errors, external amps, or certain speakers types like dipole, bipole or Dolby-enabled. If your wiring is confirmed correct, run optimization with 'Disable Speaker Inversion' option turned on.`);
  } else if (invertedCount === nSpeakers) {
    console.warn(`Nothing wrong with your speaker polarities, all speakers may seem inverted when phase inversion is elsewhere in the system!`);
  }}
async function setVolumeLevels() {
  console.infoBold(`Applied speaker volume offsets based on perceptual loudness levels (ISO 532-2):`)
  await postSafe(`${baseUrl}/${1}/target-settings`, {shape: "None"}, "Update processed");
  await postSafe(`http://localhost:4735/eq/house-curve`, targetCurvePath, "House curve set");
  await postSafe(`${baseUrl}/${1}/room-curve-settings`, {addRoomCurve: false}, "Update processed");
  await postNext('Calculate target level', 1);
  await postNext('Generate target measurement', 1);
  await postNext('Minimum phase version', nSpeakers + 2, {"include cal": false, "append lf tail": false, "append hf tail": false, "frequency warping": false, "replicate data": true});
  await postDelete(nSpeakers + 2);
  let indices = Array.from({length: nSpeakers}, (_, i) => i + 1);
  indices.push(nSpeakers + 2);
  const phonLevels = [];
  for (const index of indices) {
    const phons = await calculateLoudnessPhons(index);
    phonLevels.push(phons);
  }
  const mean = phonLevels.slice(0, -1).reduce((sum, avg) => sum + avg, 0) / (phonLevels.length - 1);
  const differences = phonLevels.map(ix => ix - mean);
  for (let i = 0; i < indices.length - 1; i++) {
    await postNext('Add SPL offset', indices[i], {offset: -differences[i]});
    customLevel[i + 1] = Math.round(-differences[i] * 2) / 2;
    customMargin[i + 1] = (-differences[i]) - customLevel[i + 1];
    console.log(`${commandId[i + 1]} --> Applied volume adjustment: ${-differences[i] > 0 ? '+' : -differences[i] === 0 ? '' : '-'}${Math.abs(-differences[i]).toFixed(5)}dB -> via AVR volume settings: ${customLevel[i + 1] > 0 ? '+' : customLevel[i + 1] === 0 ? '' : '-'}${Math.abs(customLevel[i + 1]).toFixed(1)}dB -> via filters hack: ${customMargin[i + 1].toFixed(5)}dB`);
  }
  await postNext('Add SPL offset', nSpeakers + 2, {offset: -differences.at(-1)});
  await postNext('Calculate target level', nSpeakers + 2);
  targetLevel = await fetchSafe(`${nSpeakers + 2}/target-level`);
  responseTarget = await fetchSafe(`frequency-response?smoothing=1%2F48&ppo=96`, nSpeakers + 2);
  dataTarget = new DataView(Uint8Array.from(atob(responseTarget.magnitude), c => c.charCodeAt(0)).buffer);
  console.info(`Final target level:: ${targetLevel.toFixed(5)}dB`);
  const normalizedPath = targetCurvePath.replace(/\\/g, "/");
  tcName = normalizedPath.split("/").pop().replace(/\.[^/.]+$/, "").replace(/\s+/g, "");
  tcName = `tc${tcName}${targetLevel.toFixed(1)}dB`;
  await fetchREW(nSpeakers + 2, 'PUT', {title: tcName, notes: 'Remember game theory!'});}
async function calculateLoudnessPhons(measurementNumber) {
  const p0 = 20e-6;
  const minFreq = 20;
  const maxFreq = 16000;
  const numERBbands = 40;
  const rho_c = 400;
  const ERB_1kHz_BW = 24.7 * (4.37 * 1 + 1);
  const I_0dB_1kHz = (p0 * p0) / rho_c;
  const E0_excitation_units = 1;
  const thresholdExcitation_excitation_units = Math.pow(10, 4/10);
  const specificLoudnessCalibrationConstant = 0.1013; 
  function freqToERBn(f) {return 21.4 * Math.log10(4.37e-3 * f + 1);}
  function erbnToFreq(cam) {return (Math.pow(10, cam / 21.4) - 1) / 4.37e-3;}
  function outerMiddleEarCorrection(f) {
    if (f < 100) return -20;
    if (f < 200) return -10;
    if (f < 500) return -5;
    if (f < 1000) return 0;
    if (f < 2000) return 2;
    if (f < 4000) return 4;
    if (f < 8000) return 3;
    if (f < 12000) return 0;
    return -5;
  }
  function makeERBCenters(nBands, fLow, fHigh) {
    const erbLow = freqToERBn(fLow);
    const erbHigh = freqToERBn(fHigh);
    const camStep = (erbHigh - erbLow) / (nBands - 1);
    const centers = [];
    for (let i = 0; i < nBands; i++) {
      const cam = erbLow + i * camStep;
      centers.push(erbnToFreq(cam));
    }
    return centers;
  }
  function gammatoneGain(freq, centerFreq) {
    const erb = 24.7 * (4.37 * centerFreq / 1000 + 1);
    let g;
    if (freq > centerFreq) {
      g = 1.5;
    } else {
      g = 1.0;
    }
    const fRel = (g * (freq - centerFreq)) / erb;
    return Math.pow(1 + fRel * fRel, -1.42);
  }
  function dbSPLtoExcitationSpectralDensity(db, freqStep) {
    const p = p0 * Math.pow(10, db / 20);
    const I_bin = (p * p) / rho_c;
    const spectral_density = I_bin / freqStep;
    return spectral_density;
  }
  function computeExcitation(frequencies, magnitudes, erbCenters, freqStep) {
    return erbCenters.map(center => {
      let e = 0;
      for (let i = 0; i < frequencies.length; i++) {
        const f = frequencies[i];
        const correctedDB = magnitudes[i] + outerMiddleEarCorrection(f);
        const excitation_spectral_density = dbSPLtoExcitationSpectralDensity(correctedDB, freqStep); 
        const pressure_gain = gammatoneGain(f, center);
        const power_gain = pressure_gain * pressure_gain;
        e += excitation_spectral_density * power_gain * freqStep;
      }
      return e;
    });
  }
  function excitationToSpecificLoudness(E_band_total_intensity_Wm2) {
    const exponent = 0.23;
    return E_band_total_intensity_Wm2.map(e_Wm2 => {
      const e_excitation_units = e_Wm2 / I_0dB_1kHz; 
      const term_inside_pow = (e_excitation_units - thresholdExcitation_excitation_units) / E0_excitation_units;
      let specificLoudness_val = 0;
      if (term_inside_pow > 0) {
        specificLoudness_val = specificLoudnessCalibrationConstant * Math.pow(term_inside_pow, exponent);
      }
      return specificLoudness_val;
    });
  }
  function integrateLoudness(Nprime, erbCenters) {
    const dCam = (freqToERBn(erbCenters[erbCenters.length - 1]) - freqToERBn(erbCenters[0])) / (erbCenters.length - 1);
    const totalLoudness = Nprime.reduce((sum, n) => sum + n * dCam, 0);
    return totalLoudness;
  }
  function computeLoudness(frequencies, magnitudes, freqStep) {
    const erbCenters = makeERBCenters(numERBbands, minFreq, maxFreq);
    const excitation = computeExcitation(frequencies, magnitudes, erbCenters, freqStep); 
    const specificLoudness = excitationToSpecificLoudness(excitation);
    const loudness = integrateLoudness(specificLoudness, erbCenters);
    return loudness;
  }
  const response = await fetchSafe(`frequency-response?smoothing=None`, measurementNumber);
  const {startFreq, freqStep, magnitude} = response;
  const bytes = Uint8Array.from(atob(magnitude), c => c.charCodeAt(0));
  const view = new DataView(bytes.buffer);
  const mags = new Float32Array(bytes.length / 4);
  const freqs = new Float32Array(mags.length);
  for (let i = 0; i < mags.length; i++) {
      mags[i] = view.getFloat32(i * 4, false);
      freqs[i] = startFreq + (i * freqStep);
  }
  const loudnessSones = computeLoudness(freqs, mags, freqStep);
  let loudnessPhons;
  if (loudnessSones > 0) {
      loudnessPhons = 40 + 10 * Math.log2(loudnessSones);
  } else {
      loudnessPhons = -Infinity; 
  }
  return loudnessPhons;}
async function sortBass() {
  let exactDelta, avrDelta, hiPass;
  if (subRolloffEnabled && subRolloffFreq !== null) {
    lpf4LFE = lpf4lfeValue;
    hiPass = subRolloffFreq;
    console.warn(`User override :: Subwoofer highpass filter => ${subRolloffFreq}Hz : ${subRolloffSlope}, lowpass filter ${lpf4lfeValue}Hz : LR-4`);
    await postSafe(`http://localhost:4735/eq/house-curve`, targetCurvePath, 'House curve set');
    await postSafe(`${baseUrl}/${nSpeakers + 1}/room-curve-settings`, {addRoomCurve: false}, 'Update processed');
    await postSafe(`${baseUrl}/${nSpeakers + 1}/target-settings`, {shape: 'Driver', lowPassCrossoverType: "L-R4", highPassCrossoverType: subRolloffSlope, lowPassCutoffHz: lpf4lfeValue, highPassCutoffHz: subRolloffFreq}, 'Update processed');
    await postNext('Smooth', nSpeakers + 1, {smoothing: "None"});
    await new Promise((resolve) => setTimeout(resolve, speedDelay));
    await postNext('Calculate target level', nSpeakers + 1);
    const swLevel = await fetchSafe(`${nSpeakers + 1}/target-level`);
    exactDelta = targetLevel - parseFloat(swLevel, 10);
  } else {
    let lowPassFreq = null, highPassFreq = null, highPassType = null, highPassOrder = null, volumeOffset = null;
    const lpCutoffCandidates_main_thread = freqIndex.filter(freq => freq >= 80);
    const workerScriptContent = `
          function freqToIndex(freq, startFreq, ppo, totalPoints) {
              if (freq < startFreq) return 0;
              const index = ppo * Math.log2(freq / startFreq);
              return Math.min(Math.round(index), totalPoints - 1);
          }
          function getLRFilterGain(freq, cutoff, lrOrderNumerical, type) {
              if (freq <= 0 || cutoff <= 0 || lrOrderNumerical <= 0) return -200;
              const ratio = freq / cutoff;
              const ratioPow = Math.pow(ratio, lrOrderNumerical);
              let magnitude;
              if (type === 'LP') {
                  magnitude = 1 / (1 + ratioPow);
              } else if (type === 'HP') {
                  magnitude = ratioPow / (1 + ratioPow);
              } else {
                  throw new Error("Filter type must be 'HP' or 'LP'");
              }
              if (magnitude <= 1e-10) return -200;
              return 20 * Math.log10(magnitude);
          }
          function getButterworthFilterGain(freq, cutoff, order, type) {
              if (freq <= 0 || cutoff <= 0 || order <= 0) return -200;
              const ratio = freq / cutoff;
              let magnitude;
              if (type === 'LP') {
                  magnitude = 1 / Math.sqrt(1 + Math.pow(ratio, 2 * order));
              } else if (type === 'HP') {
                  magnitude = Math.pow(ratio, order) / Math.sqrt(1 + Math.pow(ratio, 2 * order));
              } else {
                  throw new Error("Filter type must be 'HP' or 'LP'");
              }
              if (magnitude <= 1e-10) return -200;
              return 20 * Math.log10(magnitude);
          }
          function applyFilters(dataMagnitude, frequencies, hpFreq, hpConfig, lpFreq, lpConfig) {
              const filteredMagnitude = new Array(dataMagnitude.length);
              for (let i = 0; i < dataMagnitude.length; i++) {
                  const freq = frequencies[i];
                  const originalMag = dataMagnitude[i];
                  if (isNaN(originalMag)) {
                      filteredMagnitude[i] = NaN;
                      continue;
                  }
                  let hpGain, lpGain;
                  if (hpConfig.type === 'LR') {
                      const hpEffectiveOrder = hpConfig.slope / 6;
                      hpGain = getLRFilterGain(freq, hpFreq, hpEffectiveOrder, 'HP');
                  } else if (hpConfig.type === 'BW') {
                      const hpOrder = hpConfig.slope / 6;
                      hpGain = getButterworthFilterGain(freq, hpFreq, hpOrder, 'HP');
                  } else {
                      // For safety, though the main thread should only send supported types
                      hpGain = 0; // No gain change if filter type is unknown
                      self.postMessage({ type: 'warning', message: 'Worker: Unsupported HP filter type encountered: ' + hpConfig.type });
                  }
                  if (lpConfig.type === 'LR') {
                      const lpEffectiveOrder = lpConfig.slope / 6;
                      lpGain = getLRFilterGain(freq, lpFreq, lpEffectiveOrder, 'LP');
                  } else if (lpConfig.type === 'BW') {
                      const lpOrder = lpConfig.slope / 6;
                      lpGain = getButterworthFilterGain(freq, lpFreq, lpOrder, 'LP');
                  } else {
                      // For safety
                      lpGain = 0; // No gain change if filter type is unknown
                      self.postMessage({ type: 'warning', message: 'Worker: Unsupported LP filter type encountered: ' + lpConfig.type });
                  }

                  filteredMagnitude[i] = originalMag + hpGain + lpGain;
              }
              return filteredMagnitude;
          }
          function calculateVolumeAdjustmentAndError(responseToAdjust, targetMagnitude, frequencies, errorRangeStartFreq, errorRangeEndFreq, ppo, analysisStartFreq) {
              let sumDiff = 0, count = 0, sumAbsoluteDiff = 0;
              const totalPoints = frequencies.length;
              const startIndex = freqToIndex(errorRangeStartFreq, analysisStartFreq, ppo, totalPoints);
              const endIndex = freqToIndex(errorRangeEndFreq, analysisStartFreq, ppo, totalPoints);
              if (startIndex >= totalPoints || endIndex < 0 || startIndex > endIndex) {
                  return { volumeAdjustment: 0, maeError: Infinity };
              }
              for (let i = startIndex; i <= endIndex; i++) {
                  if (isFinite(responseToAdjust[i]) && isFinite(targetMagnitude[i])) {
                      sumDiff += (targetMagnitude[i] - responseToAdjust[i]);
                      count++;
                  }
              }
              if (count === 0) {
                  return { volumeAdjustment: 0, maeError: Infinity };
              }
              const volumeAdjustment = sumDiff / count;
              for (let i = startIndex; i <= endIndex; i++) {
                  if (isFinite(responseToAdjust[i]) && isFinite(targetMagnitude[i])) {
                      const alignedResponse = responseToAdjust[i] + volumeAdjustment;
                      const diff = alignedResponse - targetMagnitude[i];
                      sumAbsoluteDiff += Math.abs(diff);
                  }
              }
              const maeError = sumAbsoluteDiff / count;
              return { volumeAdjustment, maeError };
          }
          let fixedAnalysisFrequencies;
          let fixedAnalysisSubMagnitude;
          let fixedAnalysisTargetMagnitude;
          let commonPpo;
          let fixedOverallAnalysisStartFreq;
          let lpCutoffCandidates;


          const hpCutoffCandidates = Array.from({ length: 60 - 16 + 1 }, (_, i) => 16 + i); // 16Hz to 60Hz, 1Hz step
          const hpFilterConfigs = [
              { type: 'LR', slope: 24 }, { type: 'LR', slope: 36 }, { type: 'LR', slope: 48 },
              { type: 'BW', slope: 12 }, { type: 'BW', slope: 18 }, { type: 'BW', slope: 24 },
              { type: 'BW', slope: 36 }, { type: 'BW', slope: 48 }
          ];
          const lpFilterConfig = { type: 'LR', slope: 24 }; // Fixed LP filter config (LR-4)
          self.onmessage = function(event) {
              if (event.data.type === 'init') {
                  fixedAnalysisFrequencies = event.data.fixedAnalysisFrequencies;
                  fixedAnalysisSubMagnitude = event.data.fixedAnalysisSubMagnitude;
                  fixedAnalysisTargetMagnitude = event.data.fixedAnalysisTargetMagnitude;
                  commonPpo = event.data.commonPpo;
                  fixedOverallAnalysisStartFreq = event.data.fixedOverallAnalysisStartFreq;
                  lpCutoffCandidates = event.data.lpCutoffCandidates;
              } else if (event.data.type === 'task') {
                  const { errorEvalStartFreq, errorEvalEndFreq, taskId } = event.data;
                  let minMaeErrorForCurrentRange = Infinity;
                  let optimalHpFreqForCurrentRange = null;
                  let optimalHpConfigForCurrentRange = null;
                  let optimalLpFreqForCurrentRange = null;
                  let optimalLpConfigForCurrentRange = null;
                  let optimalVolumeAdjustmentForCurrentRange = null;
                  for (const hpFreq of hpCutoffCandidates) {
                      for (const lpFreq of lpCutoffCandidates) {
                          if (lpFreq <= hpFreq) continue; // Ensure LP cutoff is strictly higher than HP cutoff
                          for (const hpConfig of hpFilterConfigs) {
                              const currentLpConfig = lpFilterConfig; // Use the fixed LP filter configuration
                              const currentFilteredTarget = applyFilters(
                                  fixedAnalysisTargetMagnitude,
                                  fixedAnalysisFrequencies,
                                  hpFreq, hpConfig, lpFreq, currentLpConfig
                              );
                              const { volumeAdjustment, maeError } = calculateVolumeAdjustmentAndError(
                                  fixedAnalysisSubMagnitude,
                                  currentFilteredTarget,
                                  fixedAnalysisFrequencies,
                                  errorEvalStartFreq,
                                  errorEvalEndFreq,
                                  commonPpo,
                                  fixedOverallAnalysisStartFreq
                              );

                              if (maeError < minMaeErrorForCurrentRange) {
                                  minMaeErrorForCurrentRange = maeError;
                                  optimalHpFreqForCurrentRange = hpFreq;
                                  optimalHpConfigForCurrentRange = hpConfig;
                                  optimalLpFreqForCurrentRange = lpFreq;
                                  optimalLpConfigForCurrentRange = currentLpConfig; // Store the fixed LP config
                                  optimalVolumeAdjustmentForCurrentRange = volumeAdjustment;
                              }
                          }
                      }
                  }
                  self.postMessage({
                      type: 'taskResult',
                      taskId: taskId,
                      result: {
                          highPassFreq: optimalHpFreqForCurrentRange,
                          highPassSlope: optimalHpConfigForCurrentRange ? optimalHpConfigForCurrentRange.slope : null,
                          highPassType: optimalHpConfigForCurrentRange ? optimalHpConfigForCurrentRange.type : null,
                          lowPassFreq: optimalLpFreqForCurrentRange,
                          lowPassSlope: optimalLpConfigForCurrentRange ? optimalLpConfigForCurrentRange.slope : null,
                          lowPassType: optimalLpConfigForCurrentRange ? optimalLpConfigForCurrentRange.type : null,
                          volumeAdjustment: optimalVolumeAdjustmentForCurrentRange,
                          minError: minMaeErrorForCurrentRange,
                          optimalErrorRangeStart: errorEvalStartFreq,
                          optimalErrorRangeEnd: errorEvalEndFreq,
                      }
                  });
              }
          };
      `;
    const workerBlob = new Blob([workerScriptContent], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    const responseSubRaw = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', nSpeakers + 1);
    const responseTargetRaw = await fetchSafe('frequency-response?smoothing=1%2F48&ppo=96', nSpeakers + 2);
    const subRawStartFreq = responseSubRaw.startFreq;
    const targetRawStartFreq = responseTargetRaw.startFreq;
    const subMagnitudeDecoded = b64ToFloat32ArrayBE(responseSubRaw.magnitude);
    const targetMagnitudeDecoded = b64ToFloat32ArrayBE(responseTargetRaw.magnitude);
    const commonPpo = responseSubRaw.ppo;
    const subEndFreq = subRawStartFreq * Math.pow(2, (subMagnitudeDecoded.length - 1) / commonPpo);
    const targetEndFreq = targetRawStartFreq * Math.pow(2, (targetMagnitudeDecoded.length - 1) / commonPpo);
    const fixedOverallAnalysisStartFreq = Math.min(subRawStartFreq, targetRawStartFreq, 12);
    const fixedOverallAnalysisEndFreq = Math.max(subEndFreq, targetEndFreq, 800);
    const fixedOverallAnalysisTotalPoints = Math.round(commonPpo * Math.log2(fixedOverallAnalysisEndFreq / fixedOverallAnalysisStartFreq)) + 1;
    const fixedAnalysisFrequencies = new Array(fixedOverallAnalysisTotalPoints);
    const fixedAnalysisSubMagnitude = new Array(fixedOverallAnalysisTotalPoints);
    const fixedAnalysisTargetMagnitude = new Array(fixedOverallAnalysisTotalPoints);
    for (let i = 0; i < fixedOverallAnalysisTotalPoints; i++) {
      const freq = fixedOverallAnalysisStartFreq * Math.pow(2, i / commonPpo);
      fixedAnalysisFrequencies[i] = freq;
      if (freq >= subRawStartFreq && freq <= subEndFreq) {
          fixedAnalysisSubMagnitude[i] = subMagnitudeDecoded[freqToIndex(freq, subRawStartFreq, commonPpo, subMagnitudeDecoded.length)];
      } else {
          fixedAnalysisSubMagnitude[i] = NaN;
      }
      if (freq >= targetRawStartFreq && freq <= targetEndFreq) {
          fixedAnalysisTargetMagnitude[i] = targetMagnitudeDecoded[freqToIndex(freq, targetRawStartFreq, commonPpo, targetMagnitudeDecoded.length)];
      } else {
          fixedAnalysisTargetMagnitude[i] = NaN;
      }
    }
    console.info("Starting analysing subwoofer internals using parallel processing - speed will vary by CPU core count...");
    //console.log(`Overall Fixed Analysis Range: ${fixedOverallAnalysisStartFreq.toFixed(2)}Hz to ${fixedOverallAnalysisEndFreq.toFixed(2)}Hz (${fixedOverallAnalysisTotalPoints} points)`);
    const optimalResult = await new Promise((resolve, reject) => {
      const numWorkers = navigator.hardwareConcurrency || 4;
      const workers = [];
      let activeWorkers = 0;
      let taskIdCounter = 0;
      const taskQueue = [];
      let overallMinMaeError = Infinity;
      let overallOptimalResult = null;
      const errorEvalStartFreqCandidates = Array.from({ length: 25 - 12 + 1 }, (_, i) => 12 + i);
      const errorEvalEndFreqCandidates = Array.from({ length: Math.floor((800 - 250) / 5) + 1 }, (_, i) => 250 + i * 5);
      for (const startFreq of errorEvalStartFreqCandidates) {
          for (const endFreq of errorEvalEndFreqCandidates) {
              if (endFreq <= startFreq) continue;
              taskQueue.push({ startFreq, endFreq });
          }
      }
      console.info(`Generated ${taskQueue.length} tasks distributed over ${numWorkers} CPU cores.`);
      const sendTaskToWorker = (workerIndex) => {
          if (taskQueue.length > 0) {
              const task = taskQueue.shift();
              const currentTaskId = taskIdCounter++;
              workers[workerIndex].postMessage({
                  type: 'task',
                  errorEvalStartFreq: task.startFreq,
                  errorEvalEndFreq: task.endFreq,
                  taskId: currentTaskId
              });
          } else {
              workers[workerIndex].postMessage({ type: 'done' });
              workers[workerIndex].terminate();
              activeWorkers--;
              if (activeWorkers === 0) {
                  if (overallOptimalResult && overallOptimalResult.minError !== Infinity) {
                      resolve(overallOptimalResult);
                  } else {
                      reject(new Error("Subwoofer alignment failed to find optimal result."));
                  }
              }
          }
      };
      const handleWorkerMessage = (event, workerIndex) => {
          if (event.data.type === 'log' || event.data.type === 'warning') {
              if (event.data.type === 'warning') console.warn(`[Worker ${workerIndex}] ${event.data.message}`);
          } else if (event.data.type === 'taskResult') {
              const taskResult = event.data.result;
              if (taskResult.minError < overallMinMaeError) {
                  overallMinMaeError = taskResult.minError;
                  overallOptimalResult = taskResult;
                  console.infoUpdate(`New best: frequency range ${overallOptimalResult.optimalErrorRangeStart}Hz - ${overallOptimalResult.optimalErrorRangeEnd}Hz => mean absolute error: ${overallMinMaeError.toFixed(2)}%`);
              }
              sendTaskToWorker(workerIndex);
          }
      };
      for (let i = 0; i < numWorkers; i++) {
          const worker = new Worker(workerUrl);
          worker.name = `Worker-${i}`;
          workers.push(worker);
          activeWorkers++;
          worker.onmessage = (event) => handleWorkerMessage(event, i);
          worker.onerror = (error) => {
              console.error(`Error in Worker ${i}:`, error);
              worker.terminate();
              activeWorkers--;
              if (activeWorkers === 0) {
                  reject(new Error(`Worker ${i} failed. Subwoofer alignment aborted.`));
              }
          };

          worker.postMessage({
              type: 'init',
              fixedAnalysisFrequencies: fixedAnalysisFrequencies,
              fixedAnalysisSubMagnitude: fixedAnalysisSubMagnitude,
              fixedAnalysisTargetMagnitude: fixedAnalysisTargetMagnitude,
              commonPpo: commonPpo,
              fixedOverallAnalysisStartFreq: fixedOverallAnalysisStartFreq,
              subRawStartFreq: subRawStartFreq,
              targetRawStartFreq: targetRawStartFreq,
              subRawMagnitudeLength: subMagnitudeDecoded.length,
              targetRawMagnitudeLength: targetMagnitudeDecoded.length,
              lpCutoffCandidates: lpCutoffCandidates_main_thread
          });
          sendTaskToWorker(i);
      }
    });
    lowPassFreq = optimalResult.lowPassFreq;
    highPassFreq = optimalResult.highPassFreq;
    highPassType = optimalResult.highPassType;
    highPassOrder = optimalResult.highPassSlope;
    exactDelta = optimalResult.volumeAdjustment;
    lpf4LFE = lowPassFreq;
    hiPass = highPassFreq;
    console.info('Subwoofer analysis complete!');
    console.log(`Subwoofer highpass filter => ${highPassFreq}Hz : ${highPassType} ${highPassOrder}dB/oct, lowpass filter ${lowPassFreq}Hz : LR-4`);
  }
  console.log(`Applied volume adjustment: ${exactDelta.toFixed(5)}dB`);
  avrDelta = Math.round(exactDelta * 2) / 2;
  console.log(`AVR subwoofer volume setting: ${avrDelta.toFixed(1)}dB`);
  filterCompensation = exactDelta - avrDelta;
  if (avrDelta > subMaxTrim || avrDelta < subMinTrim) {
    const exceedAmount = avrDelta > subMaxTrim ? avrDelta - subMaxTrim : avrDelta - subMinTrim;
    console.warn(`Required subwoofer volume level exceeds AVR volume adjustment limits by ${Math.abs(exceedAmount).toFixed(1)}dB!`);
    console.warn(`Acoustica will compensate for it by precisely adjusting subwoofer filters for the exceeded amount but try to adjust your subwoofer gain levels accordingly next time you measure your system.`);
    filterCompensation += exceedAmount;
    avrDelta = Math.min(Math.max(avrDelta, subMinTrim), subMaxTrim);
    console.log(`AVR subwoofer volume setting: ${avrDelta.toFixed(1)}dB`);
  }
  let totalAdjustment = exactDelta;
  if (bassFill != 0 && subRolloffSlope != "None") {
    avrDelta += bassFill;
    totalAdjustment += bassFill;
    if (avrDelta > subMaxTrim) {
      const bassFillExceed = avrDelta - subMaxTrim;
      filterCompensation += bassFillExceed;
      console.warn(`⚠ Forced bass boost amount (${bassFill}dB) is not possible to be applied in full via AVR volume settings and will be applied via Acoustica filters!`);
      avrDelta = subMaxTrim;
    } else if (avrDelta < subMinTrim) {
      const bassFillExceed = avrDelta - subMinTrim;
      filterCompensation += bassFillExceed;
      avrDelta = subMinTrim;
    }
    console.log(`Forced bass boost: ${bassFill}dB; final AVR subwoofer volume: ${avrDelta}dB`);
  }
  console.log(`Applied additional volume via filters hack: ${filterCompensation.toFixed(5)}dB`);
  await postNext('Add SPL offset', nSpeakers + 1, {offset: totalAdjustment});
  for (let i = 1; i <= nSubs; i++) customLevel[nSpeakers + i] = avrDelta + (subTrim[i] || 0);
  await alignFronts();
  await postNext('Minimum phase version', nSpeakers + 1, {'include cal': true, 'append lf tail': false, 'append hf tail': false, 'frequency warping': false, 'replicate data': true});
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  await postNext('Arithmetic', [nSpeakers + 2, nSpeakers + 3], {function: "A / B", maxGain: subBoost, lowerLimit: hiPass, upperLimit: 500});
  await new Promise(resolve => setTimeout(resolve, speedDelay));
  await postNext('Smooth', nSpeakers + 4, {smoothing: "None"});
  await postNext('Minimum phase version', nSpeakers + 4, {'include cal': false, 'append lf tail': false, 'append hf tail': false, 'frequency warping': false, 'replicate data': true});
  if (subAllPassQ != null && subAllPassQ != 0) {
    await postSafe(`${baseUrl}/${nSpeakers + 5}/filters`, {filters: [{index: 1, enabled: true, isAuto: false, frequency: customCrossover[1], q: subAllPassQ, type: 'All pass'}]}, 'Filters set');
    await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
    await postNext('Generate predicted measurement', nSpeakers + 5);
    await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
    await postDelete(nSpeakers + 5);
  }
  let sampleCount = xt32 ? 16055 : 4096;
  const rightWindowWidth = sampleCount / 48;
  await postSafe(`${baseUrl}/${nSpeakers + 5}/ir-windows`, {leftWindowType: "Rectangular", rightWindowType: "Rectangular", leftWindowWidthms: 0, rightWindowWidthms: rightWindowWidth, refTimems: 0, addFDW: false}, "Update processed");
  await postNext("Trim IR to windows", nSpeakers + 5);
  await postDelete(nSpeakers + 5);
  await postNext('Arithmetic', [nSpeakers + 1, nSpeakers + 5], {function: "A * B"});
  await postDelete(nSpeakers + 4);
  await postDelete(nSpeakers + 3);
  await fetchREW(nSpeakers + 3, 'PUT', {title: 'Subwoofer filter'});
  await postNext("Trim IR to windows", nSpeakers + 4);
  await postDelete(nSpeakers + 4);
  await fetchREW(nSpeakers + 4, 'PUT', {title: 'Subwoofer final'});
  await generateRoll(lpf4LFE, nSpeakers + 4, true);
  const lfeName = `LFE (${lpf4LFE}Hz LPF)`;
  await fetchREW(nSpeakers + 5, 'PUT', {title: lfeName});
  const response = await fetchSafe('impulse-response?windowed=true&normalised=true&samplerate=' + (xt32 ? '48000' : '6000'), nSpeakers + 3);
  const bytes = Uint8Array.from(atob(response.data), c => c.charCodeAt(0));
  const dataView = new DataView(bytes.buffer);
  if (!xt32) sampleCount /= 8;
  const filter = new Array(sampleCount);
  for (let i = 0; i < sampleCount; i++) filter[i] = dataView.getFloat32(i * 4, false) * 0.354813398972832 * 10 ** (filterCompensation / 20);
  customFilter[0] = filter;
  console.info('Bass system optimization completed!');}
async function alignFronts() {
  const sp1 = 1, sp2 = 2, sw1 = nSpeakers + 1;
  let maxSumPower = -Infinity;
  let minSumPower = Infinity;
  const indicesToCleanInThisContext = [sp1, sp2, sw1];
  for (const sIdx of indicesToCleanInThisContext) await cleanFilters(sIdx);
  const dB2Amp = dB => Math.pow(10, dB / 20);
  const amp2Db = amp => (amp > 1e-15) ? 20 * Math.log10(amp) : -120; // Avoid log(0)
  const toRad = deg => deg * Math.PI / 180;
  const ppoFreq = (s, ppo, i) => s * Math.pow(2, i / ppo);
  const ppoIndex = (f, s, ppo) => Math.log2(f / s) * ppo;
  const twoPi = 2 * Math.PI;
  const xoCandidates = freqIndex.filter(f => f >= (minFreqFR ?? 40) && f <= (maxFreqFR ?? 250));
  const msNeg = (hardNegative ?? -20) / 1000, msPos = (hardPositive ?? 20) / 1000;
  const delayStep = 0.00003333333333333333, delayValues = [];
  for (let ts = msNeg; ts <= msPos; ts += delayStep) delayValues.push(ts);
  const inversionConfigs = [{subInverted: false}, {subInverted: true}];
  let apfQValues = [0, 0.5773502692, 0.7071067812, 1.0, 1.414213562];
  if (!noAllpass) apfQValues = [0];
  const subAmplitudeScalingFactor = 2;
  //console.info(`Using subwoofer amplitude scaling factor: ${subAmplitudeScalingFactor.toFixed(1)} (${(20 * Math.log10(subAmplitudeScalingFactor)).toFixed(3)} dB)`);
  console.info("Brute force searching optimal Front L/R + Sub configuration...");
  const optimizationStartFreq = 20;
  const optimizationEndFreq = 320;
  let bestOverallSumPower = -Infinity, bestOverallConfig = null;
  const freqResults = [];
  for (const freq of xoCandidates) {
    let speaker1_postXO, speaker2_postXO;
    speaker1_postXO = await fetchResponse(sp1, freq, false, true, 0);
    speaker2_postXO = await fetchResponse(sp2, freq, false, true, 0);
    const spk1Complex = [];
    for (let i = 0; i < speaker1_postXO.magnitude.length; i++) {
      const amp = dB2Amp(speaker1_postXO.magnitude[i]);
      const phase = toRad(speaker1_postXO.phase[i]);
      spk1Complex.push({real: amp * Math.cos(phase), imag: amp * Math.sin(phase)});
    }
    const spk2Complex = [];
    for (let i = 0; i < speaker2_postXO.magnitude.length; i++) {
      const amp = dB2Amp(speaker2_postXO.magnitude[i]);
      const phase = toRad(speaker2_postXO.phase[i]);
      spk2Complex.push({real: amp * Math.cos(phase), imag: amp * Math.sin(phase)});
    }
    for (const currentQ of apfQValues) {
      let sub_postXO;
      sub_postXO = await fetchResponse(sw1, freq, true, true, currentQ);
      const subRawAmpPhase = [];
      for (let i = 0; i < sub_postXO.magnitude.length; i++) subRawAmpPhase.push({amp: dB2Amp(sub_postXO.magnitude[i]), phase: toRad(sub_postXO.phase[i])});
      let bestConfigForFreq = {sumPower: -Infinity};
      for (const config of inversionConfigs) {
        for (const ts of delayValues) {
          let currentSum = 0, validPoints = 0;
          for (let iSub = 0; iSub < sub_postXO.magnitude.length; iSub++) {
            const f = ppoFreq(sub_postXO.startFreq, sub_postXO.ppo, iSub);
            if (f < optimizationStartFreq || f > optimizationEndFreq) continue;
            const idxSpk1 = Math.min(Math.max(Math.round(ppoIndex(f, speaker1_postXO.startFreq, speaker1_postXO.ppo)), 0), speaker1_postXO.magnitude.length - 1);
            const idxSpk2 = Math.min(Math.max(Math.round(ppoIndex(f, speaker2_postXO.startFreq, speaker2_postXO.ppo)), 0), speaker2_postXO.magnitude.length - 1);
            const spk1 = spk1Complex[idxSpk1];
            const spk2 = spk2Complex[idxSpk2];
            const subRaw = subRawAmpPhase[iSub];
            const subAmp_scaled = subRaw.amp * subAmplitudeScalingFactor;
            let adjSubPhase = subRaw.phase + twoPi * ts * f;
            if (config.subInverted) adjSubPhase += Math.PI;
            const subReal = subAmp_scaled * Math.cos(adjSubPhase);
            const subImag = subAmp_scaled * Math.sin(adjSubPhase);
            const totalReal = spk1.real + spk2.real + subReal;
            const totalImag = spk1.imag + spk2.imag + subImag;
            const lin_amp = Math.sqrt(totalReal * totalReal + totalImag * totalImag);;
            currentSum += lin_amp;
            validPoints++;
          }
          if (validPoints > 0 && currentSum > bestConfigForFreq.sumPower) bestConfigForFreq = {sumPower: currentSum, ts, subInverted: config.subInverted, validPoints, apfQ: currentQ};
        }
      }
      if (bestConfigForFreq.sumPower > -Infinity && bestConfigForFreq.validPoints > 0) {
        const avgPower = bestConfigForFreq.sumPower / bestConfigForFreq.validPoints;
        const overallMagEstimate = amp2Db(avgPower);
        freqResults.push({freq: freq, overallMagEstimate: overallMagEstimate, config: bestConfigForFreq});
        if (bestConfigForFreq.sumPower > bestOverallSumPower) {
          bestOverallSumPower = bestConfigForFreq.sumPower;
          bestOverallConfig = {freq: freq, ts: bestConfigForFreq.ts, subInverted: bestConfigForFreq.subInverted, apfQ: bestConfigForFreq.apfQ};
        }
        maxSumPower = Math.max(maxSumPower, bestConfigForFreq.sumPower);
        minSumPower = Math.min(minSumPower, bestConfigForFreq.sumPower);
      } else {
         console.warn(`No valid points found for crossover frequency ${freq} Hz within the optimization range.`);
      }
    }
  }
  let maxOverallMagEstimate = -Infinity;
  for (const result of freqResults) {if (result.overallMagEstimate > maxOverallMagEstimate) maxOverallMagEstimate = result.overallMagEstimate;}
  console.log("Front speakers + subwoofer(s) crossover performance analysis:");
  const bestResultsByFreq = new Map();
  for (const currentResult of freqResults) {
    const existingBest = bestResultsByFreq.get(currentResult.freq);
    if (!existingBest || currentResult.overallMagEstimate > existingBest.overallMagEstimate) bestResultsByFreq.set(currentResult.freq, currentResult);
  }
  const uniqueBestResults = Array.from(bestResultsByFreq.values());
  uniqueBestResults.sort((a, b) => a.freq - b.freq);
  for (const result of uniqueBestResults) {
    noAllpass ? console.log(`${result.freq}Hz => Estimated SPL: ${result.overallMagEstimate.toFixed(2)}dB | Applied delay: ${(result.config.ts * 1000).toFixed(2)}ms | Sub inverted: ${result.config.subInverted} | Allpass filter Q: ${(result.config.apfQ).toFixed(4)}`) :
    console.log(`${result.freq}Hz => Estimated SPL: ${result.overallMagEstimate.toFixed(2)}dB | Applied delay: ${(result.config.ts * 1000).toFixed(2)}ms | Sub inverted: ${result.config.subInverted}`);
  }
  if (uniqueBestResults.length > 0) {
    let overallBestResult = uniqueBestResults[0];
    for (let i = 1; i < uniqueBestResults.length; i++) {if (uniqueBestResults[i].overallMagEstimate > overallBestResult.overallMagEstimate) overallBestResult = uniqueBestResults[i];}
  }
  if (bestOverallConfig) {
    noAllpass ? console.infoBold(`Best front speakers + subwoofer configuration => Xover: ${bestOverallConfig.freq}Hz | Applied delay: ${(bestOverallConfig.ts * 1000).toFixed(4)}ms | Subwoofer inverted: ${bestOverallConfig.subInverted}| Allpass filter Q: ${(bestOverallConfig.apfQ).toFixed(4)}`) :
    console.infoBold(`Best front speakers + subwoofer configuration => Xover: ${bestOverallConfig.freq}Hz | Applied delay: ${(bestOverallConfig.ts * 1000).toFixed(4)}ms | Subwoofer inverted: ${bestOverallConfig.subInverted}`);
    customCrossover[sp1] = bestOverallConfig.freq;
    customCrossover[sp2] = bestOverallConfig.freq;
    subAllPassQ = bestOverallConfig.apfQ
    await postNext('Offset t=0', nSpeakers + 1, { offset: bestOverallConfig.ts, unit: "seconds" });
    let minDist = Infinity;
    for (let i = 1; i <= nSpeakers + nSubs; i++) {
      if (i > nSpeakers) {
        mSec[i] += bestOverallConfig.ts;
        customInvert[i] = !!(customInvert[i] ^ bestOverallConfig.subInverted);
      }
      customDistance[i] = Math.round((distFL + (mSec[i] - mSec[1]) * sOs) * 100) / 100;
      if (customDistance[i] < minDist) minDist = customDistance[i];
      if (customDistance[i] > (minDist + maxDistanceLimit)) customDistance[i] = minDist + maxDistanceLimit;
    }
    if (minDist < 0) {
      for (let i = 1; i <= nSpeakers + nSubs; i++) customDistance[i] -= minDist;
      minDist = 0;
    }
    console.infoBold('Final speaker and subwoofer distances:');
    let maxDist = minDist;
    for (let i = 1; i <= nSpeakers + nSubs; i++) {
      if (customDistance[i] > maxDist) maxDist = customDistance[i];
      console.log(`${commandId[i]}: ${customDistance[i].toFixed(2)}m (${(customDistance[i] * 3.28084).toFixed(2)}ft)`);
    }
    if ((maxDist - minDist) > 6) console.warn(`A1 Evo used 'extended' maximum speaker distance difference limit in your optimized set up (6m vs 7.35m). DO NOT view or edit distance settings in the receiver's setup menu as it may reset them back to defaults, disrupting calibration - you may check them using the WEB UI!`);
    if (customInvert[nSpeakers + 1]) await postSafe(`${baseUrl}/${nSpeakers + 1}/command`, { command: "Invert" }, "Invert completed");
  } else {
    console.error("Failed to find optimal configuration for front speakers.");
    customCrossover[sp1] = customCrossover[2] = 80;
  }
  for (let i = 3; i <= nSpeakers;) {
    const isPair = !["C", "CH", "SB", "TS"].includes(commandId[i]) && !(commandId[i] === "SBL" && !commandId.includes("SBR"));
    await optimizeSpeakers(i, isPair ? i + 1 : null);
    i += isPair ? 2 : 1;
  }
  console.infoBold("Final crossover and polarity settings:");
  for (let i = 1; i <= nSpeakers; i++) console.log(`${commandId[i]}: ${customCrossover[i]}Hz, polarity inverted? ${customInvert[i]}`);
  for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) console.log(`${commandId[i]}, polarity inverted? ${customInvert[i]}`);
  if (customInvert.some(Boolean)) console.warn("Polarity inversion(s) will be applied automatically by A1 Evo Acoustica!");}
function freqToIndex(freq, startFreq, ppo, totalPoints) {
    if (freq < startFreq) return 0;
    const index = ppo * Math.log2(freq / startFreq);
    return Math.min(Math.round(index), totalPoints - 1);}
function b64ToFloat32ArrayBE(base64) {
  const binaryStr = atob(base64);
  const len = binaryStr.length;
  const buffer = new ArrayBuffer(len);
  const uint8 = new Uint8Array(buffer);
  for (let i = 0; i < len; i++) uint8[i] = binaryStr.charCodeAt(i);
  const swapped = new Uint8Array(len);
  for (let i = 0; i < len; i += 4) {
    swapped[i]     = uint8[i + 3];
    swapped[i + 1] = uint8[i + 2];
    swapped[i + 2] = uint8[i + 1];
    swapped[i + 3] = uint8[i];
  }
  return new Float32Array(swapped.buffer);}
async function fetchResponse(index, xoFreq, isSub = false, uPPO = false, allpassQ = 0) {
  const filters = [{
    index: 21,
    enabled: true,
    isAuto: false,
    frequency: xoFreq,
    shape: isSub ? 'L-R' : 'BU',
    slopedBPerOctave: isSub ? 24 : 12,
    type: isSub ? 'Low pass' : 'High pass'
  }];
  filters.push({
      index: 20,
      enabled: allpassQ !== 0,
      isAuto: false,
      frequency: xoFreq,
      q: allpassQ,
      type: 'All pass'
  });
  await postSafe(`${baseUrl}/${index}/filters`, {filters}, 'Filters set');
  let url = `${baseUrl}/${index}/eq/frequency-response?unit=SPL`;
  if (uPPO) {
    url += '&smoothing=1%2F48&ppo=96';
  } else {
    url += '&smoothing=None';
  }
  const filterResponse = await fetch(url);
  const response = await filterResponse.json();
  if (uPPO) {
    const {startFreq, ppo, phase, magnitude} = response;
    return {
      startFreq,
      ppo,
      phase: b64ToFloat32ArrayBE(phase),
      magnitude: b64ToFloat32ArrayBE(magnitude)
    };
  } else {
      const {startFreq, freqStep, phase, magnitude} = response;
      return {
        startFreq,
        freqStep,
        phase: b64ToFloat32ArrayBE(phase),
        magnitude: b64ToFloat32ArrayBE(magnitude)
    };
  }}
async function optimizeSpeakers(sp1, sp2 = null) {
  let skipAllpassLogging = false;
  const isLimitedAVR = !xt32 && !xt;
  let apfQValues = [0, 0.5773502692, 0.7071067812, 1.0, 1.414213562];
  if (!noAllpass || isLimitedAVR) {
    apfQValues = [0];
    skipAllpassLogging = true;
  }
  const isPair = sp2 !== null;
  const sw1 = nSpeakers + 1;
  const speakerIndices = isPair ? [sp1, sp2, sw1] : [sp1, sw1];
  const dB2Amp = dB => Math.pow(10, dB / 20);
  const toRad = deg => deg * Math.PI / 180;
  const MIN_AMP_SQ = 1e-18;
  const ANALYSIS_START_F = 20;
  const ANALYSIS_END_F = 350;
  const weightFreqs = [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500];
  const weightValues = [0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.95, 0.9, 0.85, 0.8];
  const weightSlopes = weightValues.map((v, i, a) => {
    if (i === 0) return (a[1] - v) / (weightFreqs[1] - weightFreqs[0]);
    if (i === a.length - 1) return (v - a[i - 1]) / (weightFreqs[i] - weightFreqs[i - 1]);
    return (a[i + 1] - a[i - 1]) / (weightFreqs[i + 1] - weightFreqs[i - 1]);
  });
  const cubicInterpolate = (x, x0, x1, y0, y1, m0, m1) => {
    const dx = (x1 - x0);
    if (dx === 0) return y0;
    const t = (x - x0) / dx;
    const t2 = t * t;
    const t3 = t2 * t;
    return (2 * t3 - 3 * t2 + 1) * y0 + (t3 - 2 * t2 + t) * m0 * dx + (-2 * t3 + 3 * t2) * y1 + (t3 - t2) * m1 * dx;
  };
  const getWeightingAtFrequency = (f) => {
    if (f <= weightFreqs[0]) return weightValues[0];
    if (f >= weightFreqs[weightFreqs.length - 1]) return weightValues[weightValues.length - 1];
    const idx = weightFreqs.findIndex((wf, i, arr) => i < arr.length -1 && f < arr[i+1]);
    if (idx === -1) return weightValues[weightValues.length - 1];
    return cubicInterpolate(f, weightFreqs[idx], weightFreqs[idx + 1], weightValues[idx], weightValues[idx + 1], weightSlopes[idx], weightSlopes[idx + 1]);
  };
  console.infoBold(`Optimal crossover frequency analysis for speaker${isPair ? ` pair ${commandId[sp1]} + ${commandId[sp2]}` : ` ${commandId[sp1]}`} with auditory perception weighting:`);
  for (const sIdx of speakerIndices) await cleanFilters(sIdx);
  const targetResp = await fetch(`${baseUrl}/${nSpeakers + 2}/frequency-response?smoothing=1%2F48&ppo=96`).then(r => r.json());
  const targetMagArray = b64ToFloat32ArrayBE(targetResp.magnitude);
  const precomputedTargetInfo = [];
  if (targetResp && targetResp.ppo > 0) {
    for (let i = 0; i < targetMagArray.length; i++) {
      const f = targetResp.startFreq * Math.pow(2, i / targetResp.ppo);
      if (f < ANALYSIS_START_F || f > ANALYSIS_END_F) {
          precomputedTargetInfo.push(null); continue;
      }
      precomputedTargetInfo.push({ f, weight: getWeightingAtFrequency(f), targetMagValue: targetMagArray[i], targetIndex: i });
    }
  } else {
    console.error("Target response PPO is invalid or missing. Cannot proceed."); return;
  }
  const isCenter = ['C'].includes(commandId[sp1]);
  const isDolby = ['BDL', 'FDL', 'SDL'].includes(commandId[sp1]);
  const xoCandidates = freqIndex.filter(f => {
    let min, max;
    if (isCenter) {
      min = minFreqC ?? 40;
      max = maxFreqC ?? 250;
    } else {
      min = minFreq ?? 40;
      max = maxFreq ?? 250;
      if (isDolby) min = Math.max(min, 100);
    }
    return f >= min && f <= max;
  });
  let bestWorstDip = Infinity, bestWorstXO = null, bestSumDip = Infinity, bestSumXO = null;
  let bestWorstq1 = null, bestWorstq2 = null, bestSumAP1 = null, bestSumAP2 = null;
  const getPpoIndexingConstants = (speakerResponse, targetResponsePPO) => {
    const A = Math.log2(targetResp.startFreq / speakerResponse.startFreq) * speakerResponse.ppo;
    const B = speakerResponse.ppo / targetResponsePPO;
    return { A, B, magLength: speakerResponse.magnitude.length, phaseLength: speakerResponse.phase.length, isValid: true };
  };
  const calcDip = (speakerResponseData, subwooferResponseData, ppoConstsSpk, ppoConstsSub) => {
    let totalWeightedDip = 0; let validPoints = 0;
    if (!ppoConstsSpk.isValid || !ppoConstsSub.isValid) return Infinity;
    for (const targetPoint of precomputedTargetInfo) {
      if (!targetPoint) continue;
      const {weight, targetMagValue, targetIndex} = targetPoint;
      const rawIdxSpk = ppoConstsSpk.A + targetIndex * ppoConstsSpk.B;
      const idxSpk = Math.min(Math.max(Math.round(rawIdxSpk), 0), ppoConstsSpk.magLength - 1);
      const rawIdxSub = ppoConstsSub.A + targetIndex * ppoConstsSub.B;
      const idxSub = Math.min(Math.max(Math.round(rawIdxSub), 0), ppoConstsSub.magLength - 1);
      const spkAmp = dB2Amp(speakerResponseData.magnitude[idxSpk]); const spkPhaseRad = toRad(speakerResponseData.phase[idxSpk]);
      const subAmp = dB2Amp(subwooferResponseData.magnitude[idxSub]); const subPhaseRad = toRad(subwooferResponseData.phase[idxSub]);
      const realSum = spkAmp * Math.cos(spkPhaseRad) + subAmp * Math.cos(subPhaseRad);
      const imagSum = spkAmp * Math.sin(spkPhaseRad) + subAmp * Math.sin(subPhaseRad);
      const powerSum = realSum * realSum + imagSum * imagSum;
      const combinedSPL = powerSum > MIN_AMP_SQ ? 10 * Math.log10(powerSum) : -180;
      let delta = targetMagValue - combinedSPL;
      if (isLimitedAVR) delta = Math.abs(delta);
      if (delta > 0) totalWeightedDip += delta * weight;
      validPoints++;
    }
    return validPoints > 0 ? totalWeightedDip / validPoints : Infinity;
  };
  for (const freq of xoCandidates) {
    let subResponse;
    subResponse = await fetchResponse(sw1, freq, true, true, 0);
    const ppoConstsSub = getPpoIndexingConstants(subResponse, targetResp.ppo);
    let currentFreq_bestWorstDipVal = Infinity;
    let currentFreq_bestWorstDipQ1 = null;
    let currentFreq_bestWorstDipQ2 = null;
    let currentFreq_bestSumDipVal = Infinity;
    let currentFreq_bestSumDipQ1 = null;
    let currentFreq_bestSumDipQ2 = null;
    if (isPair) {
      for (const q1 of apfQValues) {
        for (const q2 of apfQValues) {
          const spk1Response = await fetchResponse(sp1, freq, false, true, q1);
          const spk2Response = await fetchResponse(sp2, freq, false, true, q2);
          const ppoConstsSpk1 = getPpoIndexingConstants(spk1Response, targetResp.ppo);
          const ppoConstsSpk2 = getPpoIndexingConstants(spk2Response, targetResp.ppo);
          const dip1 = calcDip(spk1Response, subResponse, ppoConstsSpk1, ppoConstsSub);
          const dip2 = calcDip(spk2Response, subResponse, ppoConstsSpk2, ppoConstsSub);
          const worstDip = Math.max(dip1, dip2);
          const sumDip = dip1 + dip2;
          if (worstDip < currentFreq_bestWorstDipVal) {
            currentFreq_bestWorstDipVal = worstDip;
            currentFreq_bestWorstDipQ1 = q1;
            currentFreq_bestWorstDipQ2 = q2;
          }
          if (sumDip < currentFreq_bestSumDipVal) {
            currentFreq_bestSumDipVal = sumDip;
            currentFreq_bestSumDipQ1 = q1;
            currentFreq_bestSumDipQ2 = q2;
          }
          if (worstDip < bestWorstDip) {
            bestWorstDip = worstDip;
            bestWorstXO = freq;
            bestWorstq1 = q1;
            bestWorstq2 = q2;
          }
          if (sumDip < bestSumDip) {
            bestSumDip = sumDip;
            bestSumXO = freq;
            bestSumAP1 = q1;
            bestSumAP2 = q2;
          }
        }
      }
    } else {
      for (const q1 of apfQValues) {
        const spk1Response = await fetchResponse(sp1, freq, false, true, q1);
        const ppoConstsSpk1 = getPpoIndexingConstants(spk1Response, targetResp.ppo);
        const dip1 = calcDip(spk1Response, subResponse, ppoConstsSpk1, ppoConstsSub);
        if (dip1 < currentFreq_bestWorstDipVal) {
          currentFreq_bestWorstDipVal = dip1;
          currentFreq_bestWorstDipQ1 = q1;
        }
        if (dip1 < currentFreq_bestSumDipVal) {
          currentFreq_bestSumDipVal = dip1;
          currentFreq_bestSumDipQ1 = q1;
        }
        if (dip1 < bestWorstDip) {
          bestWorstDip = dip1;
          bestWorstXO = freq;
          bestWorstq1 = q1;
          bestWorstq2 = null;
        }
        if (dip1 < bestSumDip) {
          bestSumDip = dip1;
          bestSumXO = freq;
          bestSumAP1 = q1;
          bestSumAP2 = null;
        }
      }
    }
    if (currentFreq_bestWorstDipVal !== Infinity) {
      if (isPair) {
        if (!skipAllpassLogging) {
          console.info(
            `Freq: ${freq}Hz - Worst dip ${(-currentFreq_bestWorstDipVal).toFixed(2)}dB (Left allpass Q: ${currentFreq_bestWorstDipQ1?.toFixed(4)}, Right allpass Q: ${currentFreq_bestWorstDipQ2?.toFixed(4)}) | Average dip ${(-currentFreq_bestSumDipVal / 2).toFixed(2)}dB (Left allpass Q: ${currentFreq_bestSumDipQ1?.toFixed(4)}, Right allpass Q: ${currentFreq_bestSumDipQ2?.toFixed(4)})`
          );
        } else {
          console.info(`Freq: ${freq}Hz - Worst dip ${(-currentFreq_bestWorstDipVal).toFixed(2)}dB | Average dip ${(-currentFreq_bestSumDipVal / 2).toFixed(2)}dB`);
        }
      } else {
        if (!skipAllpassLogging) {
          console.info(`Freq: ${freq}Hz - Dip ${(-currentFreq_bestWorstDipVal).toFixed(2)}dB (Q: ${currentFreq_bestWorstDipQ1?.toFixed(4)})`);
        } else {
          console.info(`Freq: ${freq}Hz - Dip ${(-currentFreq_bestWorstDipVal).toFixed(2)}dB`);
        }
      }
    } else {
      console.info(`Freq: ${freq}Hz - No valid dip calculations found or all attempts failed.`);
    }
  }
  if (!skipAllpassLogging) {
    console.info(`Overall best crossover by worst off: ${bestWorstXO}Hz, Left allpass Q: ${bestWorstq1?.toFixed(4)}${isPair && bestWorstq2 !== null ? `, Right allpass Q: ${bestWorstq2.toFixed(4)}` : ''}, dips below target: ${-bestWorstDip.toFixed(4)}`);
    console.info(`Overall best crossover by average: ${bestSumXO}Hz, Left allpass Q: ${bestSumAP1?.toFixed(4)}${isPair && bestSumAP2 !== null ? `, Right allpass Q: ${bestSumAP2.toFixed(4)}` : ''}, dips below target: ${isPair ? (-bestSumDip/2).toFixed(4) : (-bestSumDip).toFixed(4)}`);
  } else {
    console.info(`Overall best crossover by worst off: ${bestWorstXO}Hz, dip: ${-bestWorstDip.toFixed(4)}`);
    console.info(`Overall best crossover by average: ${bestSumXO}Hz, dip: ${isPair ? (-bestSumDip/2).toFixed(4) : (-bestSumDip).toFixed(4)}`);
  }
  customCrossover[sp1] = bestWorstXO;
  allpassQ[sp1] = bestWorstq1;
  console.infoBold(`  >> Assigned Crossover: ${customCrossover[sp1]}Hz${!skipAllpassLogging ? `, Left allpass Q: ${allpassQ[sp1]?.toFixed(4)}` : ''} to ${commandId[sp1]}`);
  if (isPair) {
    customCrossover[sp2] = bestWorstXO;
    allpassQ[sp2] = bestWorstq2;
    console.infoBold(`  >> Assigned Crossover: ${customCrossover[sp2]}Hz${!skipAllpassLogging ? `, Right allpass Q: ${allpassQ[sp2]?.toFixed(4)}` : ''} to ${commandId[sp2]}`);
  }}
async function refResults(){
  console.info(`Generating magnitude and phase correction filters for normal listening mode [Flat]...`);
  for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {if (customInvert[i]) {customFilter[i] = customFilter[0].map((value) => -value);} else {customFilter[i] = customFilter[0];}}
  for (let i = 1; i <= nSpeakers; i++) {
    console.info(`${commandId[i]}`);
    const filteredSub = await generateRoll(customCrossover[i], nSpeakers + 4, true);
    const filteredSpeaker = await generateRoll(customCrossover[i], i)
    const spResponse = await postNext("Vector sum", [filteredSpeaker, filteredSub]);
    await new Promise((resolve) => setTimeout(resolve, speedDelay));
    const responseKey = parseInt(Object.keys(spResponse.results)[0], 10);
    await refFilter(responseKey, i);
    await postDelete(responseKey - 1);
    await postDelete(responseKey - 2);
  }
  const allResponses = await fetchREW();
  const nTotal = Object.keys(allResponses).length;
  let ind = [];
  for (let i = 1; i <= nTotal; i++) {
    const title = allResponses[i].title;
    if (title.includes('final')) ind.push(i);
  }
  await postNext('Smooth', ind, {smoothing: "Var"});
  await new Promise((resolve) => setTimeout(resolve, speedDelay / 4));}
async function refFilter(index, orgIndex) {
  let sampleCount = xt32 ? 16321 : (xt ? 512 : 128);
  const rightWindowWidth = sampleCount / 48;
  await postNext('Smooth', index, {smoothing: "Var"});
  const mp = await postNext('Minimum phase version', index, {'include cal': true, 'append lf tail': false, 'append hf tail': false, 'frequency warping': false, 'replicate data': true});
  mpIndex = parseInt(Object.keys(mp.results)[0], 10);
  await postNext('Arithmetic', [nSpeakers + 2, mpIndex], {function: "A / B", maxGain: 0, lowerLimit: (!xt32 && !xt) ? 375 : 16, upperLimit: (!xt32 && !xt) ? 500 : 252});
  await new Promise(resolve => setTimeout(resolve, speedDelay));
  await postNext('Smooth', mpIndex + 1, {smoothing: "None"});
  await postNext('Minimum phase version', mpIndex + 1, {'include cal': true, 'append lf tail': false, 'append hf tail': false, 'frequency warping': false, 'replicate data': true});
  await postNext('Arithmetic', [index, mpIndex + 2], {function: "A * B"});
  await postNext('Minimum phase version', mpIndex + 3, {'include cal': true, 'append lf tail': false, 'append hf tail': false, 'frequency warping': false, 'replicate data': true});
  await postDelete(mpIndex + 3);
  await postNext('Smooth', mpIndex + 3, {smoothing: '1/1'});
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  await postSafe(`http://localhost:4735/eq/house-curve`, targetCurvePath, 'House curve set');
  await new Promise(resolve => setTimeout(resolve, speedDelay));
  await postSafe(`http://localhost:4735/eq/match-target-settings`, {startFrequency: 10, endFrequency: 20000, individualMaxBoostdB: 3, overallMaxBoostdB: 0, flatnessTargetdB: 1, varyQAbove200Hz: true, allowLowShelf: false, allowHighShelf: true, highShelfMin: -3, highShelfMax: 3}, 'Update processed');
  await new Promise(resolve => setTimeout(resolve, speedDelay / 10));
  await postSafe(`http://localhost:4735/eq/match-target-settings`, {startFrequency: (!xt32 && !xt) ? 375 : 200, endFrequency: 12500, individualMaxBoostdB: 3, overallMaxBoostdB: 0, flatnessTargetdB: 1, varyQAbove200Hz: true, allowLowShelf: false, allowHighShelf: true, highShelfMin: -3, highShelfMax: 3}, 'Update processed');
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  await postSafe(`${baseUrl}/${mpIndex + 3}/room-curve-settings`, {addRoomCurve: false}, 'Update processed');
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  await postSafe(`${baseUrl}/${mpIndex + 3}/target-settings`, {shape: 'None'}, 'Update processed');
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  await fetchSafe('target-level', mpIndex + 3, targetLevel);
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  await postMatchTarget(mpIndex + 3);
  await new Promise(resolve => setTimeout(resolve, speedDelay));
  await postNext('Generate filters measurement', mpIndex + 3);
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  await postNext('Smooth', mpIndex + 3, {smoothing: "None"});
  await postNext('Arithmetic', [mpIndex + 2, mpIndex + 4], {function: "A * B"});
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  await postNext('Minimum phase version', mpIndex + 5, {'include cal': true, 'append lf tail': false, 'append hf tail': false, 'frequency warping': false, 'replicate data': true});
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  if (allpassQ[orgIndex] != null && allpassQ[orgIndex] != 0) {
    await postSafe(`${baseUrl}/${mpIndex + 6}/filters`, {filters: [{index: 1, enabled: true, isAuto: false, frequency: customCrossover[orgIndex], q: allpassQ[orgIndex], type: 'All pass'}]}, 'Filters set');
    await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
    await postNext('Generate predicted measurement', mpIndex + 6);
    await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
    await postDelete(mpIndex + 6);
  }
  await postNext('Smooth', mpIndex + 6, {smoothing: "None"});
  await postSafe(`${baseUrl}/${mpIndex + 6}/ir-windows`, {leftWindowType: "Rectangular", rightWindowType: "Rectangular", leftWindowWidthms: 0, rightWindowWidthms: rightWindowWidth, refTimems: 0, addFDW: false}, "Update processed");
  await postNext("Trim IR to windows", mpIndex + 6);
  await postDelete(mpIndex + 6);
  await postNext('Arithmetic', [index, mpIndex + 6], {function: "A * B"});
  await new Promise(resolve => setTimeout(resolve, speedDelay / 4));
  for (let i = 5; i >= 2; i--) await postDelete(mpIndex + i);
  const name = (await fetchREW(orgIndex)).title.slice(0, -1);
  const filterTitle = name + "filter";
  await fetchREW(mpIndex + 2, 'PUT', {title: filterTitle});
  await fetchREW(mpIndex + 3, 'PUT', {title: filterTitle.replace("ilter", "inal")});
  const magResponse = await fetchSafe('frequency-response?smoothing=None', mpIndex + 2);
  const {startFreq, freqStep, magnitude} = magResponse;
  const index6kHz = Math.round((6000 - startFreq) / freqStep);
  const bytes2 = Uint8Array.from(atob(magnitude), c => c.charCodeAt(0));
  const totalPoints = bytes2.length / 4;
  const lastIndex = totalPoints - 1;
  const data = new DataView(bytes2.buffer);
  let sumPressure = 0, count = 0;
  for (let i = index6kHz; i <= lastIndex; i++) {
    const magValue = data.getFloat32(i * 4, false);
    sumPressure += 10 ** (magValue / 10);
    count++;
  }
  const cm = customMargin[orgIndex] + 5 * Math.log10(sumPressure / count);
  const response = await fetchSafe('impulse-response?windowed=true&normalised=true&samplerate=48000', mpIndex + 2);
  const bytes = Uint8Array.from(atob(response.data), c => c.charCodeAt(0));
  const dataView = new DataView(bytes.buffer);
  const filter = new Array(sampleCount);
  for (let i = 0; i < sampleCount; i++) {
    const invertFactor = customInvert[orgIndex] ? -1.0 : 1.0;
    filter[i] = dataView.getFloat32(i * 4, false) * 0.354813398972832 * 10 ** (cm / 20) * invertFactor;
  }
  customFilter[orgIndex] = filter;
  await postDelete(mpIndex + 1); await postDelete(mpIndex); await postDelete(index);
  return ;}
async function generateRoll(freq, index, isSub = false) {
  if (freq === 0) {
    await postSafe(`${baseUrl}/${index}/command`, {command: 'Response copy'}, 'Completed');
    const allResponses = await fetchREW();
    return parseInt(Object.keys(allResponses).length, 10);
  }
  await cleanFilters(index);
  const filter = [{
    "index": 21, "enabled": true, "isAuto": false, "frequency": freq,
    "shape": isSub ? "L-R" : "BU",
    "slopedBPerOctave": isSub ? 24 : 12,
    "type": isSub ? "Low pass" : "High pass"
  }];
  await postSafe(`${baseUrl}/${index}/filters`, {filters: filter}, "Filters set");
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  const rollResponse = await postNext('Generate predicted measurement', index);
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  return parseInt(Object.keys(rollResponse.results)[0]);}
async function multipleSubs(indices) {
  function generatePermutations(arr) {
    const permutations = [];
    const n = arr.length;
    if (n <= 1) return [arr];
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const pair = [arr[i], arr[j]];
        const remaining = arr.filter(num => !pair.includes(num));
        const permute = (prefix, nums) => {if (nums.length === 0) {permutations.push([...pair, ...prefix]);} else {nums.forEach((num, idx) => permute([...prefix, num], nums.filter((_, i) => i !== idx)));}};
        permute([], remaining);
      }
    }
    return permutations;}
  console.info(`Multiple sub optimization process starting...`);
  await postNext('Smooth', indices, {smoothing: "Psy"});
  await new Promise(resolve => setTimeout(resolve, speedDelay));
  const subShift = await postNext('Align SPL', indices, {frequencyHz: 70.71067812, spanOctaves: 3.6538562, targetdB: 'average'});
  let maxBoost = -Infinity, minBoost = Infinity;
  for (const [i, subIndex] of indices.entries()) {
    const delta = parseFloat(subShift.results[subIndex].alignSPLOffsetdB);
    const deltaRounded = Math.round(delta * 2) / 2;
    if (Math.abs(deltaRounded) > 12) {
      console.error(`Required 'relative' volume alignment for SW${i + 1} is beyond hardware limits!`);
      throwError();
    }
    subTrim[i + 1] = deltaRounded;
    maxBoost = Math.max(maxBoost, deltaRounded);
    minBoost = Math.min(minBoost, deltaRounded);
    console.log(`SW${i + 1} applied 'relative' volume adjustment: ${deltaRounded}dB`);
    await postNext('Add SPL offset', subIndex, {offset: deltaRounded - delta});
  }
  subMaxTrim -= maxBoost;
  subMinTrim -= minBoost;
  console.info(`Remaining subwoofer volume adjustment range: ${subMinTrim}dB - +${subMaxTrim}dB`);
  const allPermutations = generatePermutations(indices);
  if(nSubs >= 3) console.info(`Deploying multiple subwoofer precision alignment protocol...`);
  let bestFinalScore = -Infinity;
  let bestAlignedSumIndex = null;
  let bestmSecs = null;
  let bestInverts = null;
  let bestPermutation = null;
  let foundSolution = false;
  for (const [index, permutation] of allPermutations.entries()) {
   const percentageComplete = ((index + 1) / allPermutations.length * 100).toFixed(2);
   console.infoUpdate(`Processing permutation ${index + 1}/${allPermutations.length} (${percentageComplete}% complete): ${permutation.map(sw => `SW${sw - nSpeakers}`).join(' → ')}`);
   const result = await processSubConfig(permutation);
   if (result) {
     foundSolution = true;
     const {newIndex, finalScore, mSecs, isInverteds} = result;
     if (finalScore > bestFinalScore || bestInverts === null) {
       bestPermutation = permutation;
       bestFinalScore = finalScore;
       bestAlignedSumIndex = newIndex;
       bestmSecs = mSecs;
       bestInverts = isInverteds;
     }
   }
  };
  if (!foundSolution) {
    console.warn(`⚠ No solutions were found to time align your subwoofers with each other within your receiver hardware limits and optimization cannot continue!`);
    console.error(`Check your subwoofer(s) for causes of excessive line delays like filters, wireless dongles, MiniDSP and re-measure your system after sorting out.`);
    throwError();
  }
  bestInverts = bestInverts.map(value => value || false);
  console.log('\nOptimal multiple sub configuration found:');
  console.info('Permutation:');
  console.info(`  ${bestPermutation.map(sw => `SW${sw - nSpeakers}`).join(' → ')}`);
  console.info('Calculated optimal time delays:');
  console.info(`  ${bestmSecs.map((ms, index) => `SW${index + 1}: ${-ms.toFixed(2)}ms`).join('\n  ')}`);
  console.info('Initial polarity inversions:');
  console.info(`  ${bestInverts.map((invert, index) => `SW${index + 1}: ${invert}`).join('\n  ')}`);
  await postSafe(`${baseUrl}/${bestAlignedSumIndex}/command`, {command: "Response copy"}, "Completed");
  let allResponses = await fetchREW();
  let nTotal = Object.keys(allResponses).length;
  await fetchREW(nTotal, 'PUT', {title: "SW1o"});
  if (enableWeakBass) {// possible offset sub measurements problem
    adjustSubsVolume = -20 * Math.log10(nSubs);
    await postNext('Add SPL offset', nTotal, {offset: adjustSubsVolume});
  }
  console.info(`Subwoofers ${Array.from({length: nSubs}, (_, i) => `SW${i+1}`).join(', ').replace(/, ([^,]*)$/, ' and $1')} time aligned, level matched and summed.`);
  for (let i = nTotal - 1; i > nSpeakers; i--) await postDelete(i);
  bestmSecs.forEach((ms, k) => {
    const i = nSpeakers + 1 + k;
    mSec[i] = ms / 1000;
    customInvert[i] = bestInverts[k];
  });}
async function processSubConfig(subIndices) {
  let maxPositiveDelay = hardPositive;
  let maxNegativeDelay = hardNegative;
  let delay, newIndex, finalScore;
  subIndices.forEach(index => {customInvert[index] = false, mSec[index] = 0;});
  let indexA = subIndices[0];
  await postSafe("http://localhost:4735/alignment-tool/mode", "Impulse", "Mode set");
  await postSafe("http://localhost:4735/alignment-tool/remove-time-delay", false, "Value set");
  await postAlign('Reset all');
  for (let i = 1; i < subIndices.length; i++) {
    const indexB = subIndices[i];
    await postSafe("http://localhost:4735/alignment-tool/index-a", indexA, "selected as measurement A");
    await postSafe("http://localhost:4735/alignment-tool/index-b", indexB, "selected as measurement B");
    await postSafe("http://localhost:4735/alignment-tool/max-negative-delay", -maxPositiveDelay, "Maximum negative delay set");
    await postSafe("http://localhost:4735/alignment-tool/max-positive-delay", -maxNegativeDelay, "Maximum positive delay set");
    const {bestDelay, bestInvert, finalScore} = await optimizeSubs(indexA, indexB, maxNegativeDelay, maxPositiveDelay, 250);
    await postSafe(`http://localhost:4735/alignment-tool/delay-b`, bestDelay, `Value set`);
    await postSafe(`http://localhost:4735/alignment-tool/invert-b`, bestInvert, `Value set`);
    const alignedSum = await postAlign('Aligned sum');
    newIndex = parseInt(Object.keys(alignedSum.results)[0], 10);
    mSec[indexB] = -bestDelay;
    customInvert[indexB] = bestInvert;
    const offsetsUsed = subIndices.slice(0, i + 1).map(j => mSec[j]);
    const minOffset = Math.min(...offsetsUsed);
    const maxOffset = Math.max(...offsetsUsed);
    const currentSpread = maxOffset - minOffset;
    if (currentSpread > modelDelayLimit) {
      console.info(`No solution with that permutation: total delay spread = ${currentSpread.toFixed(2)}ms > ${modelDelayLimit}ms.`);
      return false;
    }
    const leftover = modelDelayLimit - currentSpread;
    let nextMinAllowed = Math.max(hardNegative, minOffset - leftover);
    let nextMaxAllowed = Math.min(hardPositive, maxOffset + leftover);
    if (nextMinAllowed > 0) nextMinAllowed = 0;
    if (nextMaxAllowed < 0) nextMaxAllowed = 0;
    maxNegativeDelay = nextMinAllowed;
    maxPositiveDelay = nextMaxAllowed;
    if (maxPositiveDelay < maxNegativeDelay) {
      console.info(`No solution can be found!`);
      return false;
    }
    indexA = newIndex;
  }
  return {newIndex, finalScore, mSecs: mSec.slice(-subIndices.length), isInverteds: customInvert.slice(-subIndices.length)};}
async function optimizeSubs(i1, i2, timeShiftMinMs, timeShiftMaxMs, fMax) {
  async function fetchSub(index) {
    const subResponse = await fetch(`${baseUrl}/${index}/frequency-response?unit=SPL&smoothing=None`);
    const response = await subResponse.json();
    const {startFreq, freqStep, phase, magnitude} = response;
    const base64ToFloat32ArrayBigEndian = (base64) => {
      const binaryStr = atob(base64);
      const len = binaryStr.length;
      const buffer = new ArrayBuffer(len);
      const uint8 = new Uint8Array(buffer);
      for (var i = 0; i < len; i++) uint8[i] = binaryStr.charCodeAt(i);
      const swappedBuffer = new ArrayBuffer(len);
      const src = new Uint8Array(buffer);
      const dst = new Uint8Array(swappedBuffer);
      for (var i = 0; i < len; i += 4) {
        dst[i]     = src[i + 3];
        dst[i + 1] = src[i + 2];
        dst[i + 2] = src[i + 1];
        dst[i + 3] = src[i];
      }
      return new Float32Array(swappedBuffer);};
    return {startFreq, freqStep, phase: base64ToFloat32ArrayBigEndian(phase), magnitude: base64ToFloat32ArrayBigEndian(magnitude)};}
  const dB2Amp = dB => Math.pow(10, dB / 20);
  const toRadians = deg => deg * Math.PI / 180;
  const twoPi = 2 * Math.PI;
  const sub1 = await fetchSub(i1);
  const sub2 = await fetchSub(i2);
  const {startFreq, freqStep, magnitude: mag1, phase: ph1} = sub1;
  const {magnitude: mag2, phase: ph2} = sub2;
  const lowerFreq = 16, upperFreq = fMax;
  const startIndex = Math.ceil((lowerFreq - startFreq) / freqStep);
  const endIndex = Math.floor((upperFreq - startFreq) / freqStep);
  const nIndices = endIndex - startIndex + 1;
  const dataIndices = new Array(nIndices);
  for (var i = 0; i < nIndices; i++) {
    const idx = startIndex + i;
    const freqValue = startFreq + idx * freqStep;
    const sub1Amp = dB2Amp(mag1[idx]);
    dataIndices[i] = {
      freqValue,
      sub1Real: sub1Amp * Math.cos(toRadians(ph1[idx])),
      sub1Imag: sub1Amp * Math.sin(toRadians(ph1[idx])),
      sub2Amp: dB2Amp(mag2[idx]),
      sub2PhaseRad: toRadians(ph2[idx])
    };
  }
  const timeShiftParams = {min: timeShiftMinMs / 1000, max: timeShiftMaxMs / 1000, step: 0.0000333333333333};
  const tsValues = [];
  for (var ts = timeShiftParams.min; ts <= timeShiftParams.max; ts += timeShiftParams.step) tsValues.push(ts);
  let bestConfig = {sumPower: -Infinity};
  for (var inversion = 0; inversion < 2; inversion++) {
    const sub2Inverted = inversion === 1;
    let bestForInversion = {sumPower: -Infinity, timeShift: 0};
    for (var i = 0; i < tsValues.length; i++) {
      const ts = tsValues[i];
      const tsFactor = twoPi * ts;
      let sumPower = 0;
      for (var j = 0; j < dataIndices.length; j++) {
        const d = dataIndices[j];
        let phase = d.sub2PhaseRad + tsFactor * d.freqValue;
        if (sub2Inverted) phase += Math.PI;
        const cosPhase = Math.cos(phase);
        const sinPhase = Math.sin(phase);
        const sub2Real = d.sub2Amp * cosPhase;
        const sub2Imag = d.sub2Amp * sinPhase;
        const realSum = d.sub1Real + sub2Real;
        const imagSum = d.sub1Imag + sub2Imag;
        sumPower += Math.sqrt(realSum * realSum + imagSum * imagSum);
      }
      if (sumPower > bestForInversion.sumPower) bestForInversion = {sub2Inverted, timeShift: ts, sumPower};
    }
    if (bestForInversion.sumPower > bestConfig.sumPower) bestConfig = bestForInversion;
  }
  const avgPower = bestConfig.sumPower / nIndices;
  const overallMag = 20 * Math.log10(avgPower);
  console.infoUpdate(`Analysed permutation: Required time delay: ${(bestConfig.timeShift * 1000).toFixed(3)} ms, inversion required: ${bestConfig.sub2Inverted}, estimated linear amplitude: ${overallMag.toFixed(2)} dB`);
  const bestDelay = -bestConfig.timeShift * 1000;
  const bestInvert = bestConfig.sub2Inverted;
  const finalScore = overallMag;
  return {bestDelay, bestInvert, finalScore};}
async function cleanFilters(index) {
  const filters = Array.from({length: 22}, (_, i) => ({index: i + 1, type: "None", enabled: true, isAuto: true}));
  await postSafe(`${baseUrl}/${index}/filters`, {filters}, "Filters set");
  await new Promise((resolve) => setTimeout(resolve, speedDelay / 5));}
async function fixSubs4REW() {
  console.info(`Reversing 'Linkwitz Riley 250Hz 24dB/octave lowpass filter' applied by the AVR to REW subwoofer measurements...`);
  await fetch(`http://localhost:4735/import/impulse-response-data`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(antiLPF),
  });
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  let allResponses = await fetchREW();
  const subFix = Object.keys(allResponses).length;
  await postNext('Align SPL', [subFix], {frequencyHz: 20, spanOctaves: 0, targetdB: 0});
  let measurementArray = Object.keys(allResponses).map((key) => ({
    index: parseInt(key, 10),
    title: allResponses[key].title,
  }));
  const indicesToDelete = [];
  for (let i = 1; i < measurementArray.length; i++) {
    const {index, title} = measurementArray[i];
    if (title.startsWith("SW")) {
      const fixedSub = await postNext('Arithmetic', [index, subFix], {function: "A * B"});
      await new Promise((resolve) => setTimeout(resolve, speedDelay));
      const subKey = parseInt(Object.keys(fixedSub.results)[0], 10);
      await postNext("Trim IR to windows", subKey);
      await postDelete(subKey);
      await fetchREW(subKey, 'PUT', {title: title});
      indicesToDelete.push(index);
    }
  }
  await postDelete(subFix);
  for (let i = indicesToDelete.length - 1; i >= 0; i--) await postDelete(indicesToDelete[i]);
  console.info(`All subwoofer measurements corrected!`);}
async function lowVolumeFilters() {
  console.info('Generating new set of filters for low volume listening mode [Reference]...');
  const lowVolumeFilter = await fetch(`http://localhost:4735/import/impulse-response-data`, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(spFilter[levelLowVol])});
  if (!lowVolumeFilter.ok) throw new Error('Network response was not OK!');
  const filterIndice = 3 * (nSpeakers + 1) + 3;
  await postNext('Align SPL', [filterIndice], {"frequencyHz": `5100`, "spanOctaves": `0`, "targetdB": '-0.075'});
  const deqSub = await postNext('Arithmetic', [nSpeakers + 3, filterIndice], {function: "A * B"});
  await new Promise((resolve) => setTimeout(resolve, speedDelay));
  const subKey = parseInt(Object.keys(deqSub.results)[0], 10);
  let sampleCount = xt32 ? 16055 : 4096;
  let rightWindowWidth = sampleCount / 48;
  await postSafe(`${baseUrl}/${subKey}/ir-windows`, {leftWindowType: "Rectangular", rightWindowType: "Rectangular", leftWindowWidthms: 0, rightWindowWidthms: rightWindowWidth, refTimems: 0, addFDW: false}, "Update processed");
  const response = await fetchSafe('impulse-response?windowed=true&normalised=true&samplerate=' + (xt32 ? '48000' : '6000'), subKey);
  const bytes = Uint8Array.from(atob(response.data), c => c.charCodeAt(0));
  const dataView = new DataView(bytes.buffer);
  if (!xt32) sampleCount /= 8;
  const filter = new Array(sampleCount);
  for (let i = 0; i < sampleCount; i++) filter[i] = dataView.getFloat32(i * 4, false) * Math.pow(10, ((filterCompensation - 8.99999976158142) / 20));
  deqFilter[0] = filter;
  for (let i = nSpeakers + 1; i <= nSpeakers + nSubs; i++) {if (customInvert[i]) {deqFilter[i] = deqFilter[0].map((value) => -value);} else {deqFilter[i] = deqFilter[0];}}
  await postDelete(subKey);
  let j = 1;
  sampleCount = xt32 ? 16321 : (xt ? 512 : 128);
  rightWindowWidth = sampleCount / 48;
  for (let i = nSpeakers + 6; i < filterIndice; i += 2) {
    const name = await fetchREW(i);
    const title = name.title;
    const deqSp = await postNext('Arithmetic', [i, filterIndice], {function: "A * B"});
    await new Promise((resolve) => setTimeout(resolve, speedDelay));
    const spKey = parseInt(Object.keys(deqSp.results)[0], 10); 
    await postSafe(`${baseUrl}/${spKey}/ir-windows`, {leftWindowType: "Rectangular", rightWindowType: "Rectangular", leftWindowWidthms: 0, rightWindowWidthms: rightWindowWidth, refTimems: 0, addFDW: false}, "Update processed");
    const magResponse = await fetchSafe('frequency-response?smoothing=None', spKey);
    const {startFreq, freqStep, magnitude} = magResponse;
    const index6kHz = Math.round((6000 - startFreq) / freqStep);
    const bytes2 = Uint8Array.from(atob(magnitude), c => c.charCodeAt(0));
    const totalPoints = bytes2.length / 4;
    const lastIndex = totalPoints - 1;
    const data = new DataView(bytes2.buffer);
    let sumPressure = 0, count = 0;
    for (let i = index6kHz; i <= lastIndex; i++) {
      const magValue = data.getFloat32(i * 4, false);
      sumPressure += 10 ** (magValue / 10);
      count++;
    }
    const cm = customMargin[j] + 5 * Math.log10(sumPressure / count);
    const response = await fetchSafe('impulse-response?windowed=true&normalised=true&samplerate=48000', spKey);
    const bytes = Uint8Array.from(atob(response.data), c => c.charCodeAt(0));
    const dataView = new DataView(bytes.buffer);
    const filter = new Array(sampleCount);
    for (let i = 0; i < sampleCount; i++) {
      const invertFactor = customInvert[j] ? -1 : 1;
      filter[i] = (dataView.getFloat32(i * 4, false) * Math.pow(10, ((cm - 8.99999976158142) / 20)) * invertFactor);
    }
    deqFilter[j] = filter;
    j++;
    await postDelete(spKey);
  }
  await postDelete(filterIndice);}
async function saveOcaToServer(ocaData, filename, logHtml) {
  const saveButton = document.getElementById('saveButtonId');
  if (saveButton) saveButton.disabled = true;
  const statusElement = document.getElementById('saveStatus');
  if (statusElement) statusElement.textContent = `Saving ${filename} and log...`;
  try {
    const saveUrl = '/api/save-oca';
    const payload = {
        ocaData: ocaData,
        filename: filename,
        logHtml: logHtml
    };
    const response = await fetch(saveUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    });
    if (!response.ok) {
      let errorMsg = `Server responded with status: ${response.status} ${response.statusText}`;
      try { const errorData = await response.json(); errorMsg += ` - ${errorData.message || 'No specific error message.'}`; } catch (e) {}
      throw new Error(errorMsg);
    }
    const result = await response.json();
    if (result.success) {
      console.log("Calibration and log files saved successfully by backend:", result.ocaFilename, result.logFilename);
      const successMsg = `Files saved successfully:\n- ${result.ocaFilename}\n- ${result.logFilename}\n(Located in the application folder.)`;
       if (statusElement) statusElement.textContent = successMsg;
      alert(successMsg);
    } else {
      let errMsg = result.message || 'Server reported an unspecified error during saving.';
      if(result.errorDetails) {
          errMsg += `\nDetails: ${JSON.stringify(result.errorDetails)}`;
      }
      throw new Error(errMsg);
    }
  } catch (error) {
    console.error("Error saving files via server:", error);
     const errorText = `Error saving calibration/log files:\n${error.message}`;
     if (statusElement) statusElement.textContent = errorText;
    alert(errorText);
  } finally {
     if (saveButton) saveButton.disabled = false;
  }}
async function generateOCA() {
  try {
    const now = new Date();
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const month = months[now.getMonth()];
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const timestamp = `${month}${day}_${hours}${minutes}`;
    let baseOca = {};
    baseOca.A1EvoAcoustica = evoVersion;
    baseOca.model = jsonContent.targetModelName;
    baseOca.eqType = jsonContent.enMultEQType;
    baseOca.hasGriffinLiteDSP = isGriffin;
    baseOca.ampAssign = jsonContent.ampAssign;
    baseOca.ampAssignInfo = jsonContent.ampAssignInfo;
    baseOca.channels = jsonContent.detectedChannels.map(detectedChannel => {
      const commandIdIndex = commandId.indexOf(detectedChannel.commandId);
      const trimAdjustmentInDbs = customLevel[commandIdIndex];
      const distanceInMeters = customDistance[commandIdIndex];
      const filter = customFilter[commandIdIndex];
      const filterLV = deqFilter[commandIdIndex];
      let crossover = customCrossover[commandIdIndex];
      let speakerType = detectedChannel.commandId.startsWith("SW") ? "E" : "S";
      const channel = {
      speakerType: speakerType,
      distanceInMeters: distanceInMeters,
      trimAdjustmentInDbs: trimAdjustmentInDbs,
      filter: filter,
      filterLV: filterLV,
      commandId: detectedChannel.commandId
      };
      if (crossover != null && !detectedChannel.commandId.startsWith("SW")) channel.xover = crossover;
      return channel;
    });
    baseOca.numberOfSubwoofers = nSubs;
    baseOca.lpfForLFE = lpf4LFE;
    let ocafileName;
    !subRolloffEnabled ? ocafileName = `${timestamp}_${tcName}_swFill${bassFill}_eqBoost${subBoost}_lowVolOffset${dbValues[levelLowVol]}_A1EvoAcoustica_${evoVersion}.oca` :
    ocafileName = `${timestamp}_${tcName}_swFill${bassFill}_eqBoost${subBoost}_swRoll${subRolloffFreq}_${subRolloffSlope}_lowVolOffset${dbValues[levelLowVol]}_A1EvoAcoustica_${evoVersion}.oca`;
    ocafileName = ocafileName
      .replace(/\s+/g, '_')
      .replace(/[^\w.-]/g, '_')
      .replace(/\.+/g, '.')
      .replace(/^_+|_+$/g, '')
      .replace(/_+/g, '_');
    const rawLogHtml = document.getElementById("logContainer").innerHTML;
    const logHtml = wrapLogHtml(rawLogHtml);
    await saveOcaToServer(baseOca, ocafileName, logHtml);
  } catch (error) {
     console.error("Error during .oca file generation or sending:", error);
     alert("An error occurred during the final calculation or data sending process. Please check the console for details.");
  }
  return;}
function wrapLogHtml(innerHtml) {
  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Calibration Log</title>
  <style>
    body {
      background: #1A202C;
      color: #CBD5E0;
      font-family: 'Poppins', 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
    }
    #logContainer {
      background: linear-gradient(135deg, #1A202C, #2D3748, #4A5568);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      font-size: 1rem;
      overflow-y: auto;
    }
    #logContainer .log {
      background: rgba(34, 197, 94, 0.15);
      color: #16A34A;
    }
    #logContainer .info {
      background: rgba(59, 130, 246, 0.2);
      color: #4299E1;
    }
    #logContainer .warning {
      background: rgba(237, 181, 74, 0.25);
      color: #ECC94B;
    }
    #logContainer .error {
      background: rgba(245, 101, 101, 0.9);
      color: #4A0000;
      font-weight: bold;
    }
    #logContainer .infoBold {
      background: rgba(59, 130, 246, 0.2);
      color: #3182CE;
      font-weight: bold;
    }
    #logContainer .infoGrey {
      background: rgba(59, 130, 246, 0.1);
      color: rgba(99, 179, 237, 0.5);
    }
  </style>
</head>
<body>
  <div id="logContainer">
    ${innerHtml}
  </div>
</body>
</html>`;}
function vectorDivide(impulseA, impulseB) {
  const complexA = impulseA.map(val => math.complex(val, 0));
  const complexB = impulseB.map(val => math.complex(val, 0));
  const Af = math.fft(complexA);
  const Bf = math.fft(complexB);
  const Yf = math.map(Af, (val, i) => math.divide(val, Bf[i]));
  return math.ifft(Yf).map(complex => complex.re);}
async function fastConvolution(arrayData, micCalFile) {
  return new Promise((resolve, reject) => {
    const offlineCtx = new OfflineAudioContext(1, arrayData.length, 48000);
    const bufferA = offlineCtx.createBuffer(1, arrayData.length, 48000);
    const bufferB = offlineCtx.createBuffer(1, micCalFile.length, 48000);
    bufferA.getChannelData(0).set(arrayData);
    bufferB.getChannelData(0).set(micCalFile);
    const source = offlineCtx.createBufferSource();
    const convolver = offlineCtx.createConvolver();
    convolver.normalize = true;
    source.buffer = bufferA;
    convolver.buffer = bufferB;
    source.connect(convolver);
    convolver.connect(offlineCtx.destination);
    offlineCtx.oncomplete = (e) => {
      const result = Array.from(e.renderedBuffer.getChannelData(0));
      resolve(result);
    };
    source.start(0);
    offlineCtx.startRendering().catch(reject);
  });}
document.addEventListener('DOMContentLoaded', () => {
  autoLoadConfiguration();
  fetchAppPath().catch(err => {console.warn("Initial fetch for app path failed (may affect saving):", err.message);});
  UpdateSubBoost(subBoost, true);
  UpdateBassFill(bassFill, true);
  UpdateLowVolume(levelLowVol, true);
  UpdateMinFreq(minFreq, true);
  UpdateMaxFreq(maxFreq, true);
  UpdateMinFreqFR(minFreqFR, true);
  UpdateMaxFreqFR(maxFreqFR, true);
  UpdateMinFreqC(minFreqC, true);
  UpdateMaxFreqC(maxFreqC, true);
  UpdateenableInversion(enableInversion, false);
  UpdateisWeakBass(enableWeakBass, false);
  UpdateAllPass(noAllpass, false);
  document.getElementById('bassFillSlider').addEventListener('input', function (e) {
    const normalizedValue = e.target.value.replace(',', '.');
    UpdateBassFill(parseFloat(normalizedValue), false);
  });
  document.getElementById('subBoostSlider').addEventListener('input', function (e) {
    const normalizedV = e.target.value.replace(',', '.');
    UpdateSubBoost(parseFloat(normalizedV), false);
  });
  document.getElementById('lowVolumeSlider').addEventListener('input', function() {
    UpdateLowVolume(parseInt(this.value), false);
  });
  document.getElementById('minFreqSlider').addEventListener('input', function (e) {
    const index = parseInt(e.target.value, 10);
    const value = customMinFreq[index];
    UpdateMinFreq(value, false);
  });
  document.getElementById('maxFreqSlider').addEventListener('input', function (e) {
    const index = parseInt(e.target.value, 10);
    const value = customMaxFreq[index];
    UpdateMaxFreq(value, false);
  });
  document.getElementById('minFreqSliderFR').addEventListener('input', function (e) {
    const index = parseInt(e.target.value, 10);
    const value = customMinFreqFR[index];
    UpdateMinFreqFR(value, false);
  });
  document.getElementById('maxFreqSliderFR').addEventListener('input', function (e) {
    const index = parseInt(e.target.value, 10);
    const value = customMaxFreqFR[index];
    UpdateMaxFreqFR(value, false);
  });
      document.getElementById('minFreqSliderC').addEventListener('input', function (e) {
    const index = parseInt(e.target.value, 10);
    const value = customMinFreqC[index];
    UpdateMinFreqC(value, false);
  });
  document.getElementById('maxFreqSliderC').addEventListener('input', function (e) {
    const index = parseInt(e.target.value, 10);
    const value = customMaxFreqC[index];
    UpdateMaxFreqC(value, false);
  });
  document.getElementById('disableSpeakerInversion').addEventListener('change', function (event) {
    UpdateenableInversion(event.target.checked, false);
  });
  document.getElementById('weakBass').addEventListener('change', function (event) {
    UpdateisWeakBass(event.target.checked, false);
  });
  document.getElementById('disableAllPass').addEventListener('change', function (event) {
    UpdateAllPass(event.target.checked, false);
  });
  const rolloffToggle = document.getElementById('enableRolloff');
  const rolloffFreq = document.getElementById('rolloffFreqInput');
  const rolloffSlope = document.getElementById('rolloffSlopeSelect');
  const lpf4lfeSlope = document.getElementById('lpf4lfeSlopeSelect');
  const slopeOptions = ["BE2", "BE3", "BE4", "BE5", "BE6", "BE7", "BE8", "BU1", "BU2", "BU3", "BU4", "BU5", "BU6", "BU7", "BU8", "L-R2", "L-R4", "L-R6", "L-R8"];
  const lpf4lfeOptions = ["80Hz", "90Hz", "100Hz", "110Hz", "120Hz", "150Hz", "180Hz", "200Hz", "250Hz"];
  if (rolloffSlope) {
    slopeOptions.forEach(optionValue => {
      const option = document.createElement('option');
      option.value = optionValue;
      option.textContent = optionValue;
      if (optionValue === defaultSlope) option.selected = true;
      rolloffSlope.appendChild(option);
    });
  }
  if (lpf4lfeSlope) {
    lpf4lfeOptions.forEach(optionValue => {
      const option = document.createElement('option');
      option.value = optionValue;
      option.textContent = optionValue;
      if (optionValue === lpf4lfeOptions[4]) option.selected = true;
      lpf4lfeSlope.appendChild(option);
    });
  }
  if (rolloffToggle && rolloffFreq && rolloffSlope && lpf4lfeSlope) {
    const updateRolloffValues = () => {
      subRolloffEnabled = rolloffToggle.checked;
      const parsedFreq = parseFloat(rolloffFreq.value.replace(',', '.'));
      subRolloffFreq = (subRolloffEnabled && !isNaN(parsedFreq) && parsedFreq >= 10 && parsedFreq <= 60) ? parsedFreq : null;
      subRolloffSlope = subRolloffEnabled ? rolloffSlope.value : defaultSlope;
      lpf4lfeValue = subRolloffEnabled ? parseInt(lpf4lfeSlope.value.replace('Hz', '')) : null; 
    };
    rolloffFreq.disabled = !rolloffToggle.checked;
    rolloffSlope.disabled = !rolloffToggle.checked;
    lpf4lfeSlope.disabled = !rolloffToggle.checked; 
    updateRolloffValues();
    rolloffToggle.addEventListener('change', () => {
      const isChecked = rolloffToggle.checked;
      rolloffFreq.disabled = !isChecked;
      rolloffSlope.disabled = !isChecked;
      lpf4lfeSlope.disabled = !isChecked;
      if (isChecked && (rolloffFreq.value === "" || isNaN(parseFloat(rolloffFreq.value.replace(',', '.'))) || parseFloat(rolloffFreq.value.replace(',', '.')) < 10 || parseFloat(rolloffFreq.value.replace(',', '.')) > 60 )) {rolloffFreq.value = rolloffFreq.placeholder || "25";}
      updateRolloffValues();
    });
    rolloffFreq.addEventListener('input', updateRolloffValues);
    rolloffSlope.addEventListener('change', updateRolloffValues);
    lpf4lfeSlope.addEventListener('change', updateRolloffValues);
  } else {
    console.error("One or more rolloff control elements not found!");
  }});
function autoLoadConfiguration() {
  const configFileName = 'receiver_config.avr';
  if (window.location.protocol === 'file:') {
    console.warn("Page loaded via file:// protocol. Skipping automatic fetch.");
    const loadingMsgElement = document.getElementById('loadingMessage');
    if (loadingMsgElement) loadingMsgElement.style.display = 'none';
    const manualSection = document.getElementById('manualLoadSection');
    const manualText = document.getElementById('manualLoadText');
    if (manualSection && manualText) {
        manualText.textContent = `Debug mode: Select configuration file '${configFileName}' manually to override and start optimization:`;
        manualSection.style.display = 'block';
    } else {
        throwError(`Page loaded locally, but manual input elements not found. Cannot proceed!`);
    }
    return;
  }
  console.log(`Attempting to auto-load ${configFileName} via ${window.location.protocol}...`);
  fetch(configFileName)
    .then(response => {
      console.log(`Fetch response status for ${configFileName}: ${response.status}`);
      if (!response.ok) {
        return response.json().catch(() => {
            throw new Error(`Server responded ${response.status} for ${configFileName}`);
        }).then(errData => {
            throw new Error(errData.error || `Server responded ${response.status} for ${configFileName}`);
        });
      }
       return response.json().catch(parseError => {
        console.error(`Failed to parse ${configFileName} as JSON:`, parseError);
        throw new Error(`Invalid JSON format in ${configFileName}.`);
      });
    })
    .then(data => {
      jsonContent = data;
      const loadingMsgElement = document.getElementById('loadingMessage');
      if (loadingMsgElement) loadingMsgElement.style.display = 'none';
      const measurementChoice = document.getElementById('measurementChoice');
      if (measurementChoice) measurementChoice.classList.remove('hidden');
      try {
        readContents();
      } catch (readContentsError) {
        console.error("Error occurred *inside* readContents():", readContentsError);
        throw new Error(`Error during configuration processing: ${readContentsError.message}`);
      }
    })
    .catch(error => {
      console.warn("Auto-load from server failed:", error.message);
      const loadingMsgElement = document.getElementById('loadingMessage');
      if (loadingMsgElement) loadingMsgElement.style.display = 'none';
      const manualSection = document.getElementById('manualLoadSection');
      const manualText = document.getElementById('manualLoadText');
      if (manualSection && manualText) {
        manualText.textContent = `Automatic load failed (${error.message}). Please manually select your '${configFileName}' file:`;
        manualSection.style.display = 'block';
      } else {
        throwError(`Automatic load failed: ${error.message}. Please ensure the main app is running or reload the page.`);
      }
    });}
function handleManualConfigFileSelect(event) {
  console.log("handleManualConfigFileSelect: Function started.");
  const file = event.target.files[0];
  const manualErrorDiv = document.getElementById('manualLoadError');
  if(manualErrorDiv) manualErrorDiv.textContent = '';
  if (!file) {
    console.log("handleManualConfigFileSelect: No file selected.");
    return;
  }
  console.log(`handleManualConfigFileSelect: File object obtained: ${file.name}`, file);
  jsonName = file.name;
  jsonType = file.name.split('.').pop().toLowerCase();
  const reader = new FileReader();
  reader.onload = function(e) {
    console.log("handleManualConfigFileSelect: FileReader onload triggered.");
    try {
      console.log("handleManualConfigFileSelect: Attempting to parse file content...");
      const fileContent = e.target.result;
      jsonContent = JSON.parse(fileContent);
      console.log("handleManualConfigFileSelect: Manual file parsed successfully. jsonContent:", jsonContent);
      console.log("handleManualConfigFileSelect: Attempting to update UI elements...");
      const manualSection = document.getElementById('manualLoadSection');
      if (manualSection) manualSection.style.display = 'none';
      else console.warn("handleManualConfigFileSelect: Element 'manualLoadSection' not found.");
      const measurementChoice = document.getElementById('measurementChoice');
      if (measurementChoice) measurementChoice.classList.remove('hidden');
      else console.warn("handleManualConfigFileSelect: Element 'measurementChoice' not found.");
      console.log("handleManualConfigFileSelect: Attempting to call readContents()...");
      readContents();
      console.log("Manual config file select mode activated!");
    } catch (parseOrProcessError) {
      console.error("handleManualConfigFileSelect: Error during parsing or processing:", parseOrProcessError);
      if (manualErrorDiv) {
          manualErrorDiv.textContent = `Error processing file: ${parseOrProcessError.message}. Check console for details.`;
      } else {
           alert(`Error processing file: ${parseOrProcessError.message}.`);
      }
       const measurementChoice = document.getElementById('measurementChoice');
       if (measurementChoice) measurementChoice.classList.add('hidden');
    }
  };
  reader.onerror = function(e) {
    console.error("handleManualConfigFileSelect: FileReader error:", reader.error);
    if (manualErrorDiv) {
        manualErrorDiv.textContent = `Error reading file: ${reader.error}`;
     } else {
        alert(`Error reading file: ${reader.error}`);
     }
  };
  console.log("handleManualConfigFileSelect: Calling reader.readAsText...");
  reader.readAsText(file);}
document.addEventListener('DOMContentLoaded', autoLoadConfiguration);
document.getElementById('manualConfigFileInput').addEventListener('change', handleManualConfigFileSelect);
function readContents() {
  document.getElementById('logContainer').innerHTML = '';
  const modelsSoS300 = [ "-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "C-A110", "X3700H", "X4700H","X6500H", "X6700H",
                         "X8500H", "R-A110", "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H", "-S960H", "X1400H", "X1500H", "X1600H",
                         "X1700H", "X2400H", "X2500H", "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "X3700H", "X4300H", "X4400H", "X4500H", "X4700H",
                         "X6300H", "X6400H", "X6500H", "X6700H", "X8500H", "AV7703", "AV7704", "AV7705", "AV7706", "AV8805", "NR1608", "NR1609", "NR1710",
                         "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6012", "SR6013", "SR6014", "SR6015", "SR7011", "SR7012", "SR7013", "SR7015",
                         "SR8012", "SR8015" ];
  const modelsCirrusLogic = [ "-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "-S730H", "-S740H", "-S750H", "-S760H", "-S930H", "-S940H", "-S950H",
                              "-S960H", "X1400H", "X1500H", "X1600H", "X1700H", "X2400H", "X2500H", "X2600H", "X2700H", "X3400H", "X3500H", "X3600H", "NR1608", "NR1609",
                              "NR1710", "NR1711", "SR5012", "SR5013", "SR5014", "SR5015", "SR6013", "SR6014", "-S770H", "-S970H", "X1800H", "X2800H", "EMA 60", "MA 70s" ];
  const modelsNo180xo = [ "-S720W", "-S920W", "X1300W", "X2300W", "X3300W", "NR1607", "SR5011", "SR6011", "X6500H", "-S730H", "-S740H", "-S930H", "-S940H",
                          "X1400H", "X1500H", "X2400H", "X2500H", "X3400H", "X3500H", "X4300H", "X4400H", "X4500H", "X6300H", "X6400H", "X6500H", "AV7703",
                          "AV7704", "AV7705", "NR1608", "NR1609", "SR5012", "SR5013", "SR6012", "SR6013", "SR7011", "SR7012", "SR7013", "SR8012" ];
  const griffinLite = ["X8500H", "AV8805", "X6700H", "X4700H", "AV7706", "SR8015", "SR7015", " AV 10", "VR-A1H", "VC-A1H", "X3800H", "X4800H", "EMA 30", "EMA 40", "EMA 50", "X6800H", "R-A10H", "C-A10H"];
  const baseFreq = [40, 60, 80, 90, 100, 110, 120, 150, 200, 250];
  const extraFreq = 180;
  const modelName = jsonContent.targetModelName;
  console.info(`Target AV receiver model: ${modelName}`);
  if (jsonContent.enMultEQType != 2) {
    xt32 = false;
    xt = (jsonContent.enMultEQType == 1);
    console.log(`MultEQ Type :: ${jsonContent.enMultEQType === 1 ?
      'XT (sub filter: 512 active FIR taps @ 6kHz, speaker filter: 512 active FIR taps @ 48kHz)' :
      'Basic (sub filter: active 512 FIR taps @ 6kHz, speaker filter: 128 active FIR taps @ ?kHz)'}`);
  } else {
    console.log('MultEQ Type:: XT32 (subwoofer filters: 687 active FIR taps out of 704 total, speaker filters: 1003 active FIR taps out of 1024 total @ multiple sample rates)');
  }
  const model = modelName.slice(-6);
  isGriffin = griffinLite.includes(model);
  sOs = modelsSoS300.includes(model) ? 300.00 : 343.00;
  minDistAccuracy = 3.0 / 100 / sOs / 2;
  isCirrusLogic = modelsCirrusLogic.includes(model);
  freqIndex = [...baseFreq];
  const no180 = modelsNo180xo.includes(model);
  if (!no180) freqIndex.splice(8, 0, extraFreq);
  if (!xt32) {
    const targetFreq = xt ? 90 : 40;
    const startIndex = freqIndex.indexOf(targetFreq);
    freqIndex = freqIndex.slice(startIndex);
  }
  customMinFreq = freqIndex.filter(freq => freq < 180);
  customMaxFreq = freqIndex.filter(freq => freq >= 40);
  customMinFreqFR = freqIndex.filter(freq => freq < 180);
  customMaxFreqFR = freqIndex.filter(freq => freq >= 40);
	customMinFreqC = freqIndex.filter(freq => freq < 180);
  customMaxFreqC = freqIndex.filter(freq => freq >= 40);
   distFL = 2.75;
  console.info(`Model specific speed of sound setting: ${sOs} m/s`);
  console.info(`Model is capable of setting 180Hz crossover: ${!no180}`);
  console.info(`Model has Cirrus Logic DSP chip: ${isCirrusLogic}`);};
async function fetchAppPath() {
  if (localAppPath !== null) return Promise.resolve(localAppPath);
  //console.log("Fetching application base path from backend...");
  try {
      const response = await fetch('/api/get-app-path');
      if (!response.ok) {
           const errData = await response.json().catch(() => ({ error: 'Unknown error fetching path' }));
          throw new Error(errData.error || `Server responded ${response.status}`);
      }
      const data = await response.json();
      if (!data.appPath) {
          throw new Error("Backend did not return a valid app path.");
      }
      localAppPath = data.appPath;
      //console.log("Application base path received:", localAppPath);
      return localAppPath;
  } catch (error) {
      console.error("Failed to fetch application path:", error);
      throwError(`Could not get the application path from the backend needed for saving files. Error: ${error.message}`);
      localAppPath = null;
      throw error; // Re-throw so calling functions know it failed
  }}
function UpdateSubBoost(subBoostDb, syncSlider) {
  subBoost = subBoostDb;
  if (!isNaN(subBoostDb)) {
    document.getElementById('subBoostValue').textContent = subBoostDb + ' dB';
  } else {
    console.error(`Invalid input: ${subBoostDb}`);
  }
  if (syncSlider) {
    document.getElementById('subBoostSlider').value = subBoostDb;
  }}
function UpdateBassFill(bassFillDb, syncSlider) {
  bassFill = bassFillDb;
  if (!isNaN(bassFillDb)) {
    document.getElementById('bassFillValue').textContent = bassFillDb + ' dB';
  } else {
    console.error(`Invalid input: ${bassFillDb}`);
  }
  if (syncSlider) {
    document.getElementById('bassFillSlider').value = bassFillDb;
  }}
function UpdateLowVolume(position, syncSlider) {
  // Update the global variable
  levelLowVol = position;
  
  // Update display
  const offsetDisplay = document.getElementById('lowVolumeOffset');
  offsetDisplay.textContent = dbValues[position] + ' dB';
  
  // Update slider if needed
  if (syncSlider) {
    document.getElementById('lowVolumeSlider').value = position;
  }}
function UpdateMinFreq(minFreqHz, syncSlider) {
  if (!isNaN(minFreqHz)) {
    if (minFreqHz > maxFreq) return;
    minFreq = minFreqHz;
    document.getElementById('minFreqValue').textContent = minFreqHz + ' Hz';
    if (syncSlider) {
      const index = customMinFreq.indexOf(minFreqHz);
      if (index !== -1) document.getElementById('minFreqSlider').value = index;
    }
  }}
function UpdateMaxFreq(maxFreqHz, syncSlider) {
  if (!isNaN(maxFreqHz)) {
    if (maxFreqHz < minFreq) return;
    maxFreq = maxFreqHz;
    document.getElementById('maxFreqValue').textContent = maxFreqHz + ' Hz';
    if (syncSlider) {
      const index = customMaxFreq.findIndex(freq => Math.abs(freq - maxFreqHz) < 0.1);
      if (index !== -1) document.getElementById('maxFreqSlider').value = index; 
    }
  }}
function UpdateMinFreqFR(minFreqHzFR, syncSlider) {
  if (!isNaN(minFreqHzFR)) {
    if (minFreqHzFR > maxFreqFR) return;
    minFreqFR = minFreqHzFR;
    document.getElementById('minFreqValueFR').textContent = minFreqHzFR + ' Hz';
    if (syncSlider) {
      const index = customMinFreq.indexOf(minFreqHzFR);
      if (index !== -1) document.getElementById('minFreqSliderFR').value = index;
    }
  }}
function UpdateMaxFreqFR(maxFreqHzFR, syncSlider) {
  if (!isNaN(maxFreqHzFR)) {
    if (maxFreqHzFR < minFreqFR) return;
    maxFreqFR = maxFreqHzFR;
    document.getElementById('maxFreqValueFR').textContent = maxFreqHzFR + ' Hz';
    if (syncSlider) {
      const index = customMaxFreq.findIndex(freq => Math.abs(freq - maxFreqHzFR) < 0.1);
      if (index !== -1) document.getElementById('maxFreqSliderFR').value = index; 
    }
  }}

    function UpdateMinFreqC(minFreqHzC, syncSlider) {
  if (!isNaN(minFreqHzC)) {
    if (minFreqHzC > maxFreqC) return;
    minFreqC = minFreqHzC;
    document.getElementById('minFreqValueC').textContent = minFreqHzC + ' Hz';
    if (syncSlider) {
      const index = customMinFreq.indexOf(minFreqHzC);
      if (index !== -1) document.getElementById('minFreqSliderC').value = index;
    }
  }}
function UpdateMaxFreqC(maxFreqHzC, syncSlider) {
  if (!isNaN(maxFreqHzC)) {
    if (maxFreqHzC < minFreqC) return;
    maxFreqC = maxFreqHzC;
    document.getElementById('maxFreqValueC').textContent = maxFreqHzC + ' Hz';
    if (syncSlider) {
      const index = customMaxFreq.findIndex(freq => Math.abs(freq - maxFreqHzC) < 0.1);
      if (index !== -1) document.getElementById('maxFreqSliderC').value = index; 
    }
  }}
function UpdateisWeakBass(disableWB, syncToggle) {
  enableWeakBass = disableWB;
  if (syncToggle) {
    document.getElementById('weakBass').checked = disableWB;
  }}
function UpdateAllPass(disableUP, syncToggle) {
  noAllpass = disableUP;
  if (syncToggle) {
    document.getElementById('disableAllPass').checked = disableUP;
  }}
function UpdateenableInversion(disableInv, syncToggle) {
  enableInversion = disableInv;
  if (syncToggle) {
    document.getElementById('disableSpeakerInversion').checked = disableInv;
  }}
async function updateAPI(endpoint, bodyValue) {
  const url = `http://localhost:4735/application/${endpoint}`;
  await fetch(url, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(bodyValue)
  });}
async function clearCommands() {
  const body = {command: 'Clear command in progress'};
  await updateAPI('command', body);}
async function fetchREW(indice = null, method = 'GET', body = null){
  let _body;
  let requestUrl;
  if (indice === null) {requestUrl = baseUrl;} else {requestUrl = baseUrl + `/${indice}`};
  if (method === 'PUT') {_body = body}
  while (true) {
    try {
      const response = await fetch(requestUrl, {
        method: method,
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(_body)
      });
      if (!response.ok) {
        await new Promise(resolve => setTimeout(resolve, speedDelay));
      } else {
        const data = await response.json();
        return data;
      }
    } catch (error) {
      throwError('Error fetching result:', error);
    }
  }}
async function fetchSafe(requestUrl, indice = null, parameters = null){
  const extUrl = indice ? `${baseUrl}/${indice}/${requestUrl}` : `${baseUrl}/${requestUrl}`;
  let options;
  if (parameters === null) {
    options = {
      method: 'GET'
    };
  } else {
    options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(parameters)
    };
  }
  while (true) {
    try {
      const response = await fetch(extUrl, options);
      if (!response.ok) {
        await new Promise(resolve => setTimeout(resolve, speedDelay));
      } else {
        const data = await response.json();
        return data;
      }
    } catch (error) {
      throwError('Error fetching result: ' + error);
    }
  }}
async function fetchAlign(requestUrl){
  try {
    const extUrl = `http://localhost:4735/alignment-tool/${requestUrl}`;
    const response = await fetch(extUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    if (!response.ok) {
      throwError(`HTTP error ${response.status}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    throwError('Error fetching result:', error);
  }}
async function postNext(processName, indices, parameters = null, maxRetries = 3) {
  const isProcessMeasurements = Array.isArray(indices);
  const isTrimCommand = processName === "Trim IR to windows";
  const isEqCommand = !isProcessMeasurements && !isTrimCommand && parameters === null;
  const requestUrl = isTrimCommand
    ? `${baseUrl}/${indices}/command`
    : isProcessMeasurements
    ? `${baseUrl}/process-measurements`
    : `${baseUrl}/${indices}/${isEqCommand ? 'eq/command' : 'command'}`;
  const body = {
    ...(isProcessMeasurements 
      ? { 
          processName,
          measurementIndices: indices 
        }
      : { 
          command: processName 
        }),
    ...(parameters && {parameters})
  };
  const fetchWithRetry = async (retryCount = 0) => {
    try {
      const response = await fetch(requestUrl, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body)
      });

      if (!response.ok) {
        const errorData = await response.json();
        if (response.status === 500 && 
            errorData.message?.includes('timed out') && 
            retryCount < maxRetries) {
          console.warn(`Attempt ${retryCount + 1} failed, retrying in 5 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 5000));
          return fetchWithRetry(retryCount + 1);
        }
        console.error('Network response was not OK!');
        throw new Error(errorData.message || 'Network response was not OK');
      }
      return response.json();
    } catch (error) {
      if (retryCount < maxRetries) {
        console.warn(`Attempt ${retryCount + 1} failed, retrying in 5 seconds...`);
        await new Promise(resolve => setTimeout(resolve, 5000));
        return fetchWithRetry(retryCount + 1);
      }
      console.error('Network response was not OK!');
      throw new Error(errorData.message || 'Network response was not OK');
    }
  };
  const checkResponse = async (data) => {
    if (data.message?.includes('ompleted')) {
      const resultResponse = await fetch(`${baseUrl}/process-result`);
      if (!resultResponse.ok) {
        console.error('Failed to fetch result data!');
      }
      return resultResponse.json();
    }
    if (data.message?.includes('in progress') || data.message?.includes('running')) {
      await new Promise(resolve => setTimeout(resolve, speedDelay));
      return checkResponse(await fetchWithRetry());
    }
    return data;
  };
  try {
    const data = await fetchWithRetry();
    return await checkResponse(data);
  } catch (error) {
      console.error('Network response was not OK!');
      throw new Error(errorData.message || 'Network response was not OK');
  }}
async function postSafe(requestUrl, parameters, message) {
  async function fetchData() {
    const body = typeof parameters === 'string' 
      ? parameters 
      : JSON.stringify(parameters);
    const headers = typeof parameters === 'string'
      ? { 'Content-Type': 'text/plain; charset=UTF-8' }
      : { 'Content-Type': 'application/json' };
    const response = await fetch(requestUrl, {
      method: 'POST',
      headers,
      body,
    });
    if (!response.ok) throw new Error('Network response was not OK!');
    const text = await response.text();
    try {
      return JSON.parse(text);
    } catch (e) {
      return { message: text };
    }
  }
  let data = await fetchData();
  while (true) {
    if (data.message.includes(message)) {
      return data;
    } else if (data.message.includes('in progress') || data.message.includes('running')) {
      await new Promise((resolve) => setTimeout(resolve, speedDelay));
      data = await fetchData();
    } else {
      throw new Error(`Unexpected response: ${data.message}`);
    }
  }}
async function postAlign(processName, frequency = null) {
  try {
    const response = await fetch('http://localhost:4735/alignment-tool/command', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ 
        command: processName,
        ...(frequency != null && {frequency})
      })
    });
    const responseText = await response.text();
    const data = JSON.parse(responseText);
    const parsedMessage = JSON.parse(data.message);
    if (parsedMessage.results?.[0]?.Error) {
      const errorMessage = parsedMessage.results[0].Error;
      const delayMatch = errorMessage.match(/delay required to align the responses.*(-?[\d.]+) ms/);
      if (delayMatch) {
        return { 
          message: 'Delay too large', 
          error: errorMessage, 
          delay: parseFloat(delayMatch[1]) 
        };
      }
    }
    return parsedMessage;
  } catch (error) {
    throwError(error);
  }}
async function postDelete(indice){
  const mDeleted = `Measurement ${indice} deleted`
  while (true) {
    try {
      const response = await fetch(`${baseUrl}/${indice}`, {
        method: 'DELETE',
        headers: {'Content-Type': 'application/json'},
      });
      if (!response.ok) {
        throwError('Network response was not OK!');
      }
      const data = await response.json();
      if (data.message === mDeleted) {
        return indice;
      } else {
        await new Promise(resolve => setTimeout(resolve, speedDelay));
      }
    } catch (error) {
      throwError('Error fetching result:', error);
    }
  }}
async function postMatchTarget(measurementId) {
  const commandUrl = `${baseUrl}/${measurementId}/eq/command`;
  const statusUrl = `${baseUrl}/process-result`;
  try {
    console.log(`Initiating match target for measurement ${measurementId}...`);
    const response = await fetch(commandUrl, {
      method: "POST",
      headers: {"Content-Type": "application/json", "Accept": "application/json", "Connection": "keep-alive", "Cache-Control": "no-cache"},
      body: JSON.stringify({ command: "Match target" })
    });
    let responseData;
    try {
      responseData = await response.json();
    } catch (e) {
      responseData = null;
    }
    if (response.status === 400 && responseData && responseData.message) {
      let innerData;
      try {
        innerData = JSON.parse(responseData.message);
      } catch (e) {
        innerData = null;
      }
      if (innerData && innerData.results && Object.values(innerData.results).some(r => r.Error && r.Error.includes("The range over which EQ could be applied is too narrow"))) {
        console.log("No extra filters were necessary!");
        return {success: true, result: innerData, message: "No filters were necessary - the frequency range was too narrow for EQ application"};
      }
    }
    if (!response.ok) {
      const errorMessage = responseData ? JSON.stringify(responseData) : `HTTP error ${response.status}: ${response.statusText}`;
      console.error(`Match target request failed: ${errorMessage}`);
      return {success: false, error: `Request failed with status ${response.status}`, details: errorMessage};
    }
    const postResult = responseData;
    const idMatch = postResult.message.match(/Match target ID (\d+)/);
    if (!idMatch) throw new Error("Could not extract target ID from initial response");
    const targetId = idMatch[1];
    console.log(`Match target initiated with ID: ${targetId}`);
    await new Promise(resolve => setTimeout(resolve, 2000));
    let completed = false;
    let attempts = 0;
    const maxAttempts = 3;
    const pollInterval = 1000;
    while (!completed && attempts < maxAttempts) {
      attempts++;
      console.log(`Checking status (attempt ${attempts}/${maxAttempts})...`);
      try {
        const statusResponse = await fetch(statusUrl, {headers: {"Accept": "application/json", "Connection": "keep-alive", "Cache-Control": "no-cache"}});
        if (!statusResponse.ok) {
          console.warn(`Status check failed with status: ${statusResponse.status}`);
          await new Promise(resolve => setTimeout(resolve, pollInterval));
          continue;
        }
        const reader = statusResponse.body.getReader();
        const decoder = new TextDecoder();
        let statusMessage = "";
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) statusMessage += decoder.decode(value, {stream: true});
        }
        statusMessage += decoder.decode();
        const statusResult = JSON.parse(statusMessage);
        const statusIdMatch = statusResult.processName?.match(/Match target ID (\d+)/);
        if (statusIdMatch) {
          const currentId = statusIdMatch[1];
          if (currentId !== targetId) {
            console.warn(`ID mismatch: Expected ${targetId}, got ${currentId}`);
            await new Promise(resolve => setTimeout(resolve, pollInterval));
            continue;
          }
        }
        console.log(`Status update: ${statusResult.message}`);
        if (statusResult.message.includes("Completed")) {
          completed = true;
          const narrowRangeError = statusResult.results && Object.values(statusResult.results).some(r => r.Error && r.Error.includes("The range over which EQ could be applied is too narrow"));
          if (narrowRangeError) {
            console.log("No extra filters were necessary!");
            return {success: true, targetId, result: statusResult, message: "No filters were necessary"
            };
          }
          console.log("Match target operation completed successfully");
          return { success: true, targetId, result: statusResult };
        }
      } catch (err) {
        console.error(`Error checking status: ${err.message}`);
      }
      if (!completed) await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    if (!completed) throw new Error(`Match target operation timed out after ${maxAttempts} attempts`);
  } catch (error) {
    console.error(`Match target operation failed: ${error.message}`);
    return {success: false, error: error.message};
  }}
async function putSafe(requestUrl, parameters, message){
  const fetchData = async () => {
    const response = await fetch(requestUrl, {
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(parameters),
    });
    if (!response.ok) {
      throwError('Network response was not OK!');
    }
    const data = await response.json();
    return data;
  };
  const checkResponse = async (data) => {
    if (data.message.includes(message)) {
      return data;
    } else if (data.message.includes('in progress') || data.message.includes('running') || data.message.includes('Saved all')) {
      await new Promise((resolve) => setTimeout(resolve, speedDelay));
      return checkResponse(await fetchData());
    } else {
      throwError(`Unexpected response: ${data.message}`);
    }
  };
  try {
    const data = await fetchData();
    const result = await checkResponse(data);
    return result;
  } catch (error) {
    throwError;
  }}
function throwError(errorInput){
   console.error(">>> A1Evo Error:", errorInput); // Log it clearly
    alert(errorInput);
    clearCommands();
    updateAPI('inhibit-graph-updates', false);
    updateAPI('blocking', false);
    throw new Error;}
micCalFile.splice(0, 8192, ...micCalData);
micCalData.length = 0;
{
  const canvas = document.createElement('canvas');
  canvas.width = 32; canvas.height = 32;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#0077b6';
  ctx.beginPath();
  ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, Math.PI * 2, true);
  ctx.fill();
  ctx.font = 'bold 14px Arial';
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Evo', canvas.width / 2, canvas.height / 2);
  const faviconUrl = canvas.toDataURL('image/png');
  const link = document.createElement('link');
  link.rel = 'icon';
  link.href = faviconUrl;
  document.head.appendChild(link);}
(function () {
  const logContainer = document.getElementById('logContainer');
  const TIME_LIMIT_MS = 10000;
  function scrollToBottom() {
    logContainer.scrollTop = logContainer.scrollHeight;
  }
  const lastInfoEntries = {};
  console.warn = function (...args) {
    const warningMessage = args.join(' ');
    const warningEntry = `<div class="warning">${new Date().toLocaleTimeString()} [WARNING] ${warningMessage}</div>`;
    logContainer.insertAdjacentHTML('beforeend', warningEntry);
    scrollToBottom();
  };
  console.info = function (...args) {
    const infoMessage = args.join(' ');
    const infoEntry = `<div class="info">${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}</div>`;
    logContainer.insertAdjacentHTML('beforeend', infoEntry);
    scrollToBottom();
  };
  console.infoBold = function (...args) {
    const infoBoldMessage = args.join(' ');
    const infoBoldEntry = `<div class="infoBold">${new Date().toLocaleTimeString()} [INFORMATION] ${infoBoldMessage}</div>`;
    logContainer.insertAdjacentHTML('beforeend', infoBoldEntry);
    scrollToBottom();
  };
  console.infoUpdate = function (...args) {
      const infoMessage = args.join(' ');
      const messageKey = infoMessage.replace(/\d+/g, '').replace(/\b(true|false)\b/, '').trim();
      const currentTime = Date.now();
      if (lastInfoEntries[messageKey] && (currentTime - lastInfoEntries[messageKey].timestamp < TIME_LIMIT_MS)) {
        lastInfoEntries[messageKey].element.innerHTML = `${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}`;
        lastInfoEntries[messageKey].timestamp = currentTime;
      } else {
        const infoEntry = `<div class="info">${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}</div>`;
        logContainer.insertAdjacentHTML('beforeend', infoEntry);
        lastInfoEntries[messageKey] = {
          element: logContainer.lastElementChild,
          timestamp: currentTime
        };
      }
      scrollToBottom();
    };
    console.infoGreyUpdate = function (...args) {
      const infoMessage = args.join(' ');
      const messageKey = infoMessage.split(/[0-9]/)[0].trim();
      const currentTime = Date.now();
      if (lastInfoEntries[messageKey] && (currentTime - lastInfoEntries[messageKey].timestamp < TIME_LIMIT_MS)) {
        lastInfoEntries[messageKey].element.innerHTML = `${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}`;
        lastInfoEntries[messageKey].timestamp = currentTime;
      } else {
        const infoEntry = `<div class="infoGrey">${new Date().toLocaleTimeString()} [INFORMATION] ${infoMessage}</div>`;
        logContainer.insertAdjacentHTML('beforeend', infoEntry);
        lastInfoEntries[messageKey] = {
          element: logContainer.lastElementChild,
          timestamp: currentTime
        };
      }
      scrollToBottom();
    };
    console.log = function (...args) {
    const logMessage = args.join(' ');
    const logEntry = `<div class="log">${new Date().toLocaleTimeString()} [IMPORTANT] ${logMessage}</div>`;
    logContainer.insertAdjacentHTML('beforeend', logEntry);
    scrollToBottom();
  };
    console.error = function (...args) {
    const errorMessage = args.join(' ');
    const errorEntry = `<div class="error">${new Date().toLocaleTimeString()} [ERROR] ${errorMessage}</div>`;
    logContainer.insertAdjacentHTML('beforeend', errorEntry);
    scrollToBottom();
  };})();
</script>
</body></html>